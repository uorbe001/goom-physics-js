if (typeof define !== 'function') {
	var define = require('amdefine')(module);
}

define(["./body_force_registry", "./collision_detector", "./contact_resolver", "./bounding_volume_hierarchy_node", "./bounding_sphere", "./primitives", "goom-math"], function(BodyForceRegistry, CollisionDetector, ContactResolver, BoundingVolumeHierarchyNode, BoundingSphere, Primitives, Mathematics) {
	/**
		Creates a World for the physics simulation.
		@class This class holds the different rigid bodies and the force generator/rigid body
		registry. Will also be used to run the physics simulations.
		@exports World as Physics.World
		@property {Array} rigidBodies The array with the different rigid bodies in the world.
		@property {Array} planes The array with the different planes in the world.
		@property {BodyForceRegistry} registry The registry holding all the rigid body and force
		generator pairs.
		@property {Physics.CollisionDetector} collisionDetector This is used to detect collisions between different primitives.
		@property {Physics.ContactResolver} contactResolver The contact resolver is used for contact resolution.
		@property {Physics.BoundingVolumeHierarchyNode} boundingVolumeHierarchy This will be the root node of the BVH, used for broad-phase collision detection.
	*/
	var World = (function() {
		function World() {
			this.rigidBodies = [];
			this.planes = [];
			this.registry = new BodyForceRegistry();
			this.collisionDetector = new CollisionDetector();
			this.contactResolver = new ContactResolver();
			this.boundingVolumeHierarchy = null;
			this.__potentialContacts = [];
			this.__contacts = [];
		}

		/**
			Processes all the physics in the world, updating the state of the different objects and calculating internal data before.
			@param {Number} duration Duration of the applied force in seconds.
		*/
		World.prototype.update = function(duration) {
			//Update the forces generated by force generators
			this.registry.updateForces(duration);

			//Integrate the bodies
			for (var i = 0, len = this.rigidBodies.length; i < len; i++) {
				body = this.rigidBodies[i];
				body.integrate(duration);
			}

			//TODO: Clean up caches and stuff.
			//Look up the bvh for potential contacts (broad-phase detection)
			this.boundingVolumeHierarchy.potentialContacts(this.__potentialContacts);
			//TODO: Contact restitution and friction data CANNOT be hardcoded. This is just a temporary thing.
			data = {restitution: 0, friction: 0};

			var potential_contact;
			//Check each potential contact (narrow-phase detection)
			for (i = 0, len = this.__potentialContacts.length; i < len; i++) {
				potential_contact = this.__potentialContacts[i];
				this.collisionDetector.checkForContacts(potential_contact[0], potential_contact[1], data, this.__contacts);
			}

			var plane, body, j, len2;
			//Check against the world boundaries
			for (i = 0, len = this.planes.length; i < len; i++) {
				plane = this.planes[i];
				for (j = 0, len2 = this.rigidBodies.length; j < len2; j++) {
					body = this.rigidBodies[j];
					this.collisionDetector.checkForContactsWithPlane(body, plane, data, contacts);
				}
			}

			//Contact resolution.
			this.contactResolver.resolve(this.__contacts, duration);
		};

		/**
			Adds a body to the list of rigid bodies in the world and if the second parameter is given, the list of primitives for that body is added.
			@param {RigidBody} body The rigid body to add to the world.
			@param {Number} [radious] Radious of the bounding volume sphere used for narrow phase collision detection.
			@param {Array} [primitives] An array or a single element describing primitives related to this body. If this param is not given, the body will not collide with anything.
		*/
		World.prototype.addBody = function(body, radious, primitives) {
			this.rigidBodies.push(body);
			//If we have a radious, create a BVH node and add a bounding sphere with the body to it
			if ((radious !== null && radious !== undefined) && (this.boundingVolumeHierarchy !== null && this.boundingVolumeHierarchy !== undefined)) {
				this.boundingVolumeHierarchy.insert(body, new BoundingSphere(body.position, radious));
			} else if (radious !== null && radious !== undefined) {
				this.boundingVolumeHierarchy = new BoundingVolumeHierarchyNode(null, body, new BoundingSphere(body.position, radious));
			}

			//No need to keep going if there is no primitives
			if (primitives === null || primitives === undefined) return;
			body.addPrimitives(primitives);
		};

		/**
			Adds a half plane to the physics world, all rigid bodies will be checked against it per frame.
			@param {Array} data An array or a single element describing the plane.
		*/
		World.prototype.addPlane = function(data) {
			if (!(data instanceof Array)) {
				this.planes.push(new Primitives.Plane(this, new Mathematics.Vector3D(data.normal.x, data.normal.y, data.normal.z), data.offset !== null && data.offset !== undefined ? data.offset : null));
				return;
			}

			var one_plane_data;
			//We've got an array
			for (var i = 0, len = data.length; i < len; i++) {
				one_plane_data = data[i];
				this.planes.push(new Primitives.Plane(this, new Mathematics.Vector3D(one_plane_data.normal.x, one_plane_data.normal.y, one_plane_data.normal.z), one_plane_data.offset !== null && one_plane_data.offset !== undefined ? one_plane_data.offset : null));
			}
		};

		/**
			Registers a force generator to affect a body.
			@param {Physics.RigidBody} body The rigid body to be affected by the given force generator.
			@param {Physics.ForceGenerator} force_generator The force generator affecting the given body.
		*/
		World.prototype.registerBodyAffectedByForceGenerator = function(body, force_generator) {
			this.registry.add(body, force_generator);
		};
		/**
			Removes a force generator and affected body pair from the registry.
			@param {Physics.RigidBody} body The rigid body affected by the given force generator.
			@param {Physics.ForceGenerator} force_generator The force generator affecting the given body.
		*/
		World.prototype.unregisterBodyAffectedByForceGenerator = function(body, force_generator) {
			this.registry.remove(body, force_generator);
		};

		return World;
	})();

	return World;
});