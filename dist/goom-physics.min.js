
define("src/vector3d",[],function(){var a=function(){function a(a,b,c){this.x=a!==null&&a!==undefined?a:0,this.y=b!==null&&b!==undefined?b:0,this.z=c!==null&&c!==undefined?c:0}return a.prototype.set=function(a,b,c){return this.x=a,this.y=b,this.z=c,this},a.prototype.clone=function(b){if(b===null||b===undefined)b=new a;return b.x=this.x,b.y=this.y,b.z=this.z,b},a.prototype.add=function(a,b){if(b===null||b===undefined)b=this;return b.x=this.x+a.x,b.y=this.y+a.y,b.z=this.z+a.z,b},a.prototype.scale=function(a,b){if(b===null||b===undefined)b=this;return b.x=this.x*a,b.y=this.y*a,b.z=this.z*a,b},a.prototype.substract=function(a,b){if(b===null||b===undefined)b=this;return b.x=this.x-a.x,b.y=this.y-a.y,b.z=this.z-a.z,b},a.prototype.length=function(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z)},a.prototype.magnitude=function(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z)},a.prototype.squaredMagnitude=function(){return this.x*this.x+this.y*this.y+this.z*this.z},a.prototype.crossProduct=function(a,b){var c,d;if(b===null||b===undefined)b=this;return c=this.y*a.z-this.z*a.y,d=this.z*a.x-this.x*a.z,b.z=this.x*a.y-this.y*a.x,b.x=c,b.y=d,b},a.prototype.dotProduct=function(a){return this.x*a.x+this.y*a.y+this.z*a.z},a.prototype.componentProduct=function(a,b){if(b===null||b===undefined)b=this;return b.x=this.x*a.x,b.y=this.y*a.y,b.z=this.z*a.z,b},a.prototype.normalize=function(a){var b,c;if(a===null||a===undefined)a=this;return c=this.magnitude(),b=1/c,c===0?(a.x=0,a.y=0,a.z=0,a):c===1?(a.x=this.x,a.y=this.y,a.z=this.z,a):(a.x=this.x*b,a.y=this.y*b,a.z=this.z*b,a)},a.prototype.zero=function(){return this.x=this.y=this.z=0,this},a.RIGHT=new a(1,0,0),a.UP=new a(0,1,0),a.LEFT=new a(-1,0,0),a.DOWN=new a(0,-1,0),a.Z_AXIS=new a(0,0,1),a}();return a}),define("src/quaternion",["./vector3d"],function(a){var b=function(){function a(a,b,c,d){this.r=a!==null&&a!==undefined?a:1,this.i=b!==null&&b!==undefined?b:0,this.j=c!==null&&c!==undefined?c:0,this.k=d!==null&&d!==undefined?d:0}return a.prototype.makeIdentity=function(){return this.r=1,this.i=this.j=this.k=0,this},a.prototype.set=function(a,b,c,d){return this.r=a,this.i=b,this.j=c,this.k=d,this},a.prototype.normalize=function(){var a=this.r*this.r+this.i*this.i+this.j*this.j+this.k*this.k;return a===0?(this.r=1,this):(a=1/Math.sqrt(a),this.r*=a,this.i*=a,this.j*=a,this.k*=a,this)},a.prototype.multiply=function(a,b){if(b===null||b===undefined)b=this;var c=this.r*a.r-this.i*a.i-this.j*a.j-this.k*a.k,d=this.r*a.i+this.i*a.r+this.j*a.k-this.k*a.j,e=this.r*a.j+this.j*a.r+this.k*a.i-this.i*a.k;return b.k=this.r*a.k+this.k*a.r+this.i*a.j-this.j*a.i,b.r=c,b.i=d,b.j=e,b},a.prototype.rotateByVector=function(a,b){if(b===null||b===undefined)b=this;var c=-this.i*a.x-this.j*a.y-this.k*a.z,d=this.r*a.x+this.j*a.z-this.k*a.y,e=this.r*a.y+this.k*a.x-this.i*a.z;return b.k=this.r*a.z+this.i*a.y-this.j*a.x,b.r=c,b.i=d,b.j=e,b},a.prototype.addVector=function(a,b){if(b===null||b===undefined)b=this;var c=-a.x*this.i-a.y*this.j-a.z*this.k,d=a.x*this.r+a.y*this.k-a.z*this.j,e=a.y*this.r+a.z*this.i-a.x*this.k,f=a.z*this.r+a.x*this.j-a.y*this.i;return b.r=this.r+c*.5,b.i=this.i+d*.5,b.j=this.j+e*.5,b.k=this.k+f*.5,b},a}();return b}),define("src/matrix3d",["./vector3d"],function(a){var b=function(){function a(){typeof Float32Array!="undefined"&&Float32Array!==null?this.data=new Float32Array(9):this.data=new Array(9),this.makeIdentity()}return a.prototype.clone=function(b){if(b===null||b===undefined)b=new a;for(var c=0;c<=8;c++)b.data[c]=this.data[c];return b},a.prototype.set=function(a){for(var b=0;b<=8;b++)this.data[b]=a[b];return this},a.prototype.setDiagonal=function(a,b,c){return this.data[0]=a,this.data[4]=b,this.data[8]=c,this},a.prototype.makeFromVectors=function(a,b,c){return this.data[0]=a.x,this.data[1]=a.y,this.data[2]=a.z,this.data[3]=b.x,this.data[4]=b.y,this.data[5]=b.z,this.data[6]=c.x,this.data[7]=c.y,this.data[8]=c.z,this},a.prototype.makeSkewSymmetric=function(a){return this.data[0]=this.data[4]=this.data[8]=0,this.data[1]=a.z,this.data[2]=-a.y,this.data[3]=-a.z,this.data[5]=a.x,this.data[6]=a.y,this.data[7]=-a.x,this},a.prototype.makeIdentity=function(){for(var a=0;a<=8;a++)this.data[a]=0;return this.data[0]=this.data[4]=this.data[8]=1,this},a.prototype.transpose=function(a){if(a===null||a===undefined)a=this;var b=this.data[1];return a.data[1]=this.data[3],a.data[3]=b,b=this.data[2],a.data[2]=this.data[6],a.data[6]=b,b=this.data[5],a.data[5]=this.data[7],a.data[7]=b,a.data[0]=this.data[0],a.data[4]=this.data[4],a.data[8]=this.data[8],a},a.prototype.inverse=function(a){if(a===null||a===undefined)a=this;var b=this.data[0]*this.data[4],c=this.data[0]*this.data[7],d=this.data[3]*this.data[1],e=this.data[6]*this.data[1],f=this.data[3]*this.data[2],g=this.data[6]*this.data[2],h=b*this.data[8]-c*this.data[5]-d*this.data[8]+e*this.data[5]+f*this.data[7]-g*this.data[4];if(h===0)return a.data[0]=this.data[0],a.data[1]=this.data[1],a.data[2]=this.data[2],a.data[3]=this.data[3],a.data[4]=this.data[4],a.data[5]=this.data[5],a.data[6]=this.data[6],a.data[7]=this.data[7],a.data[8]=this.data[8],a;var i=1/h,j=(this.data[4]*this.data[8]-this.data[7]*this.data[5])*i,k=-(this.data[1]*this.data[8]-this.data[7]*this.data[2])*i,l=(this.data[1]*this.data[5]-this.data[4]*this.data[2])*i,m=-(this.data[3]*this.data[8]-this.data[6]*this.data[5])*i,n=(this.data[0]*this.data[8]-g)*i,o=-(this.data[0]*this.data[5]-f)*i,p=(this.data[3]*this.data[7]-this.data[6]*this.data[4])*i,q=-(c-e)*i,r=(b-d)*i;return a.data[0]=j,a.data[1]=k,a.data[2]=l,a.data[3]=m,a.data[4]=n,a.data[5]=o,a.data[6]=p,a.data[7]=q,a.data[8]=r,a},a.prototype.add=function(a,b){if(b===null||b===undefined)b=this;for(var c=0;c<=8;c++)b.data[c]=this.data[c]+a.data[c];return b},a.prototype.multiply=function(a,b){if(b===null||b===undefined)b=this;var c=this.data[0]*a.data[0]+this.data[3]*a.data[1]+this.data[6]*a.data[2],d=this.data[1]*a.data[0]+this.data[4]*a.data[1]+this.data[7]*a.data[2],e=this.data[2]*a.data[0]+this.data[5]*a.data[1]+this.data[8]*a.data[2],f=this.data[0]*a.data[3]+this.data[3]*a.data[4]+this.data[6]*a.data[5],g=this.data[1]*a.data[3]+this.data[4]*a.data[4]+this.data[7]*a.data[5],h=this.data[2]*a.data[3]+this.data[5]*a.data[4]+this.data[8]*a.data[5],i=this.data[0]*a.data[6]+this.data[3]*a.data[7]+this.data[6]*a.data[8],j=this.data[1]*a.data[6]+this.data[4]*a.data[7]+this.data[7]*a.data[8],k=this.data[2]*a.data[6]+this.data[5]*a.data[7]+this.data[8]*a.data[8];return b.data[0]=c,b.data[1]=d,b.data[2]=e,b.data[3]=f,b.data[4]=g,b.data[5]=h,b.data[6]=i,b.data[7]=j,b.data[8]=k,b},a.prototype.scale=function(a,b){if(b===null||b===undefined)b=this;for(var c=0;c<=8;c++)b.data[c]=a*this.data[c];return b},a.prototype.transformVector=function(a,b){if(b===null||b===undefined)b=a;var c=a.x*this.data[0]+a.y*this.data[3]+a.z*this.data[6],d=a.x*this.data[1]+a.y*this.data[4]+a.z*this.data[7];return b.z=a.x*this.data[2]+a.y*this.data[5]+a.z*this.data[8],b.x=c,b.y=d,b},a.prototype.transformTransposeVector=function(a,b){if(b===null||b===undefined)b=a;var c=a.x*this.data[0]+a.y*this.data[1]+a.z*this.data[2],d=a.x*this.data[3]+a.y*this.data[4]+a.z*this.data[5];return b.z=a.x*this.data[6]+a.y*this.data[7]+a.z*this.data[8],b.x=c,b.y=d,b},a}();return b}),define("src/matrix4d",["./vector3d","./quaternion","./matrix3d"],function(a,b,c){var d=function(){function b(){typeof Float32Array!==undefined&&Float32Array!==null?this.data=new Float32Array(16):this.data=new Array(16),this.makeIdentity()}return b.prototype.clone=function(a){if(a===null||a===undefined)a=new b;for(var c=0;c<=15;c++)a.data[c]=this.data[c];return a},b.prototype.set=function(a){for(var b=0;b<=15;b++)this.data[b]=a[b];return this},b.prototype.makeIdentity=function(){for(var a=0;a<=15;a++)this.data[a]=0;return this.data[0]=this.data[5]=1,this.data[10]=this.data[15]=1,this},b.prototype.makeTranslation=function(a,b,c){return this.makeIdentity(),this.data[12]=a,this.data[13]=b,this.data[14]=c,this},b.prototype.translate=function(a,b,c,d){if(d===null||d===undefined)d=this;for(var e=0;e<=11;e++)d.data[e]=this.data[e];return d.data[12]=this.data[0]*a+this.data[4]*b+this.data[8]*c+this.data[12],d.data[13]=this.data[1]*a+this.data[5]*b+this.data[9]*c+this.data[13],d.data[14]=this.data[2]*a+this.data[6]*b+this.data[10]*c+this.data[14],d.data[15]=this.data[3]*a+this.data[7]*b+this.data[11]*c+this.data[15],d},b.prototype.makeScale=function(a,b,c){return this.makeIdentity(),this.data[0]=a,this.data[5]=b,this.data[10]=c,this},b.prototype.scale=function(a,b,c,d){if(d===null||d===undefined)d=this;return d.data[0]=this.data[0]*a,d.data[1]=this.data[1]*a,d.data[2]=this.data[2]*a,d.data[3]=this.data[3]*a,d.data[4]=this.data[4]*b,d.data[5]=this.data[5]*b,d.data[6]=this.data[6]*b,d.data[7]=this.data[7]*b,d.data[8]=this.data[8]*c,d.data[9]=this.data[9]*c,d.data[10]=this.data[10]*c,d.data[11]=this.data[11]*c,d.data[12]=this.data[12],d.data[13]=this.data[13],d.data[14]=this.data[14],d.data[15]=this.data[15],d},b.prototype.makeRotation=function(a,b){this.makeIdentity();var c=Math.cos(b),d=Math.sin(b),e=1-c;return a.magnitude()>0&&(a.normalize(),this.data[0]=e*a.x*a.x+c,this.data[1]=e*a.x*a.y+a.z*d,this.data[2]=e*a.z*a.x-a.y*d,this.data[4]=e*a.x*a.y-a.z*d,this.data[5]=e*a.y*a.y+c,this.data[6]=e*a.z*a.y-a.x*d,this.data[8]=e*a.z*a.x+a.y*d,this.data[9]=e*a.y*a.z+a.x*d,this.data[10]=e*a.z*a.z+c),this},b.prototype.transpose=function(a){if(a===null||a===undefined)a=this;var b=this.data[1];return a.data[1]=this.data[4],a.data[4]=b,b=this.data[2],a.data[2]=this.data[8],a.data[8]=b,b=this.data[3],a.data[3]=this.data[12],a.data[12]=b,b=this.data[6],a.data[6]=this.data[9],a.data[9]=b,b=this.data[7],a.data[7]=this.data[13],a.data[13]=b,b=this.data[11],a.data[11]=this.data[14],a.data[14]=b,a},b.prototype.makeFrustum=function(a,b,c,d,e,f){this.makeIdentity();var g=b-a,h=d-c,i=f-e,j=2*e;return this.data[0]=j/g,this.data[5]=j/h,this.data[8]=(b+a)/g,this.data[9]=(d+c)/h,this.data[10]=-(f+e)/i,this.data[11]=-1,this.data[14]=-j*f/i,this.data[15]=0,this},b.prototype.makePerspective=function(a,b,c,d){var e=b*Math.tan(a/(180*Math.PI)/2);return this.makeFrustum(-e,e,-e/d,e/d,b,c)},b.prototype.makeOrthographic=function(a,b,c,d,e,f){var g=b-a,h=d-c,i=f-e;return this.data[0]=2/g,this.data[1]=0,this.data[2]=0,this.data[3]=0,this.data[4]=0,this.data[5]=2/h,this.data[6]=0,this.data[7]=0,this.data[8]=0,this.data[9]=0,this.data[10]=-2/i,this.data[11]=0,this.data[12]=-(a+b)/g,this.data[13]=-(d+c)/h,this.data[14]=-(f+e)/i,this.data[15]=1,this},b.prototype.makeFromQuaternion=function(a){return this.data[0]=1-(2*a.j*a.j+2*a.k*a.k),this.data[1]=2*a.i*a.j-2*a.k*a.r,this.data[2]=2*a.i*a.k+2*a.j*a.r,this.data[3]=0,this.data[4]=2*a.i*a.j+2*a.k*a.r,this.data[5]=1-(2*a.i*a.i+2*a.k*a.k),this.data[6]=2*a.j*a.k-2*a.i*a.r,this.data[7]=0,this.data[8]=2*a.i*a.k-2*a.j*a.r,this.data[9]=2*a.j*a.k+2*a.i*a.r,this.data[10]=1-(2*a.i*a.i+2*a.j*a.j),this.data[11]=0,this.data[12]=this.data[13]=this.data[14]=0,this.data[15]=1,this},b.prototype.makeFromPositionAndOrientation=function(a,b){return this.data[0]=1-(2*b.j*b.j+2*b.k*b.k),this.data[1]=2*b.i*b.j-2*b.k*b.r,this.data[2]=2*b.i*b.k+2*b.j*b.r,this.data[3]=0,this.data[4]=2*b.i*b.j+2*b.k*b.r,this.data[5]=1-(2*b.i*b.i+2*b.k*b.k),this.data[6]=2*b.j*b.k-2*b.i*b.r,this.data[7]=0,this.data[8]=2*b.i*b.k-2*b.j*b.r,this.data[9]=2*b.j*b.k+2*b.i*b.r,this.data[10]=1-(2*b.i*b.i+2*b.j*b.j),this.data[11]=0,this.data[12]=a.x,this.data[13]=a.y,this.data[14]=a.z,this.data[15]=1,this},b.prototype.add=function(a,b){if(b===null||b===undefined)b=this;for(var c=0;c<=15;c++)b.data[c]=this.data[c]+a.data[c];return b},b.prototype.multiply=function(a,b){if(b===null||b===undefined)b=this;var c=this.data[0]*a.data[0]+this.data[4]*a.data[1]+this.data[8]*a.data[2]+this.data[12]*a.data[3],d=this.data[1]*a.data[0]+this.data[5]*a.data[1]+this.data[9]*a.data[2]+this.data[13]*a.data[3],e=this.data[2]*a.data[0]+this.data[6]*a.data[1]+this.data[10]*a.data[2]+this.data[14]*a.data[3],f=this.data[3]*a.data[0]+this.data[7]*a.data[1]+this.data[11]*a.data[2]+this.data[15]*a.data[3],g=this.data[0]*a.data[4]+this.data[4]*a.data[5]+this.data[8]*a.data[6]+this.data[12]*a.data[7],h=this.data[1]*a.data[4]+this.data[5]*a.data[5]+this.data[9]*a.data[6]+this.data[13]*a.data[7],i=this.data[2]*a.data[4]+this.data[6]*a.data[5]+this.data[10]*a.data[6]+this.data[14]*a.data[7],j=this.data[3]*a.data[4]+this.data[7]*a.data[5]+this.data[11]*a.data[6]+this.data[15]*a.data[7],k=this.data[0]*a.data[8]+this.data[4]*a.data[9]+this.data[8]*a.data[10]+this.data[12]*a.data[11],l=this.data[1]*a.data[8]+this.data[5]*a.data[9]+this.data[9]*a.data[10]+this.data[13]*a.data[11],m=this.data[2]*a.data[8]+this.data[6]*a.data[9]+this.data[10]*a.data[10]+this.data[14]*a.data[11],n=this.data[3]*a.data[8]+this.data[7]*a.data[9]+this.data[11]*a.data[10]+this.data[15]*a.data[11],o=this.data[0]*a.data[12]+this.data[4]*a.data[13]+this.data[8]*a.data[14]+this.data[12]*a.data[15],p=this.data[1]*a.data[12]+this.data[5]*a.data[13]+this.data[9]*a.data[14]+this.data[13]*a.data[15],q=this.data[2]*a.data[12]+this.data[6]*a.data[13]+this.data[10]*a.data[14]+this.data[14]*a.data[15],r=this.data[3]*a.data[12]+this.data[7]*a.data[13]+this.data[11]*a.data[14]+this.data[15]*a.data[15];return b.data[0]=c,b.data[1]=d,b.data[2]=e,b.data[3]=f,b.data[4]=g,b.data[5]=h,b.data[6]=i,b.data[7]=j,b.data[8]=k,b.data[9]=l,b.data[10]=m,b.data[11]=n,b.data[12]=o,b.data[13]=p,b.data[14]=q,b.data[15]=r,b},b.prototype.axisVector=function(b,c){if(c===null||c===undefined)c=new a;return c.set(this.data[b*4],this.data[b*4+1],this.data[b*4+2])},b.prototype.transformVector=function(a,b){if(b===null||b===undefined)b=a;var c=a.x*this.data[0]+a.y*this.data[4]+a.z*this.data[8]+this.data[12],d=a.x*this.data[1]+a.y*this.data[5]+a.z*this.data[9]+this.data[13];return b.z=a.x*this.data[2]+a.y*this.data[6]+a.z*this.data[10]+this.data[14],b.x=c,b.y=d,b},b.prototype.transformInverseVector=function(a,b){if(b===null||b===undefined)b=a;var c=this.data,d=a.x-c[12],e=a.y-c[13],f=a.z-c[14];return b.x=d*c[0]+e*c[1]+f*c[2],b.y=d*c[4]+e*c[5]+f*c[6],b.z=d*c[8]+e*c[9]+f*c[10],b},b.prototype.transformMatrix3D=function(a,b){if(b===null||b===undefined)b=a;var c=this.data,d=this.data,e=c[0]*d[0]+c[4]*d[1]+c[8]*d[2],f=c[0]*d[3]+c[4]*d[4]+c[8]*d[5],g=c[0]*d[6]+c[4]*d[7]+c[8]*d[8],h=c[1]*d[0]+c[5]*d[1]+c[9]*d[2],i=c[1]*d[3]+c[5]*d[4]+c[9]*d[5],j=c[1]*d[6]+c[5]*d[7]+c[9]*d[8],k=c[2]*d[0]+c[6]*d[1]+c[10]*d[2],l=c[2]*d[3]+c[6]*d[4]+c[10]*d[5],m=c[2]*d[6]+c[6]*d[7]+c[10]*d[8];b.data[0]=e*c[0]+f*c[4]+g*c[8],b.data[1]=h*c[0]+i*c[4]+j*c[8],b.data[2]=k*c[0]+l*c[4]+m*c[8],b.data[3]=e*c[1]+f*c[5]+g*c[9],b.data[4]=h*c[1]+i*c[5]+j*c[9],b.data[5]=k*c[1]+l*c[5]+m*c[9],b.data[6]=e*c[2]+f*c[6]+g*c[10],b.data[7]=h*c[2]+i*c[6]+j*c[10],b.data[8]=k*c[2]+l*c[6]+m*c[10]},b}();return d}),define("src/goom-math",["./vector3d","./quaternion","./matrix3d","./matrix4d"],function(a,b,c,d){return Mathematics={},Mathematics.Vector3D=a,Mathematics.Quaternion=b,Mathematics.Matrix3D=c,Mathematics.Matrix4D=d,Mathematics});
define("goom-math", function(){});

if (typeof define !== 'function') {
	var define = require('amdefine')(module);
}

define('src/bounding_sphere',["goom-math"], function(Mathematics) {
	/**
		Creates a BoundingSphere.
		@class A BoundingSphere is a kind of Bounding Volume used for broad-phase collision detection in Bounding Volume Hierarchies.
		@exports BoundingSphere as Physics.BoundingSphere
		@param {Mathematics.Vector3D} position The origin position of the sphere.
		@param {Number} [radious=1] The radious of the sphere.
		@property {Mathematics.Vector3D} position The origin position of the sphere.
		@property {Number} radious The radious of the sphere.
		@property {Mathematics.Vector3D} __helperVector This vector is used in a few functions as a local variable,
			it is defined as a class variable to avoid the creation of objects at runtime.
	*/
	var BoundingSphere = (function() {
		function BoundingSphere(position, radious) {
			if (position === null || position === undefined) position = new Mathematics.Vector3D();
			this.radious = radious !== null  && radious !== undefined? radious : 1;
			this.position = position.clone();
			this.__helperVector = new Mathematics.Vector3D();
		}

		/**
			Creates a BoundingSphere to enclose the two given spheres.
			@param {Physiscs.BoundingSphere} sphere_one The first bounding sphere to enclose.
			@param {Physiscs.BoundingSphere} sphere_two The second bounding sphere to enclose.
			@returns {Physics.BoundingSphere} The constructed BoundingSphere.
		*/
		BoundingSphere.createfromSpheres = function(sphere_one, sphere_two) {
			var position, radious;
			var center_offset = new Mathematics.Vector3D();
			sphere_two.position.substract(sphere_one.position, center_offset);
			var distance = center_offset.squaredMagnitude();
			var radious_diff = sphere_two.radious - sphere_one.radious;

			if ((radious_diff * radious_diff) >= distance) {
				if (sphere_one.radious > sphere_two.radious) {
					position = sphere_one.position.clone();
					radious = sphere_one.radious;
				} else {
					position = sphere_two.position.clone();
					radious = sphere_two.radious;
				}
			} else {
				distance = Math.sqrt(distance);
				radious = (distance + sphere_one.radious + sphere_two.radious) * 0.5;
				position = sphere_one.position.clone();
				if (distance > 0) position.add(center_offset.scale((radious - sphere_one.radious) / distance));
			}

			return new BoundingSphere(position, radious);
		};

		/**
			Makes this BoundingSphere enclose the two given spheres.
			@param {Physiscs.BoundingSphere} sphere_one The first bounding sphere to enclose.
			@param {Physiscs.BoundingSphere} sphere_two The second bounding sphere to enclose.
		*/
		BoundingSphere.prototype.fitSpheres = function(sphere_one, sphere_two) {
			var x = sphere_two.position.x - sphere_one.position.x,
				y = sphere_two.position.y - sphere_one.position.y,
				z = sphere_two.position.z - sphere_one.position.z;
			var distance = x * x + y * y + z * z;
			var radious_diff = sphere_two.radious - sphere_one.radious;

			if ((radious_diff * radious_diff) >= distance) {
				if (sphere_one.radious > sphere_two.radious) {
					sphere_one.position.clone(this.position);
					this.radious = sphere_one.radious;
				} else {
					sphere_two.position.clone(this.position);
					this.radious = sphere_two.radious;
				}
			} else {
				distance = Math.sqrt(distance);
				this.radious = (distance + sphere_one.radious + sphere_two.radious) * 0.5;
				sphere_one.position.clone(this.position);
				if (distance > 0) {
					var s = (this.radious - sphere_one.radious) / distance;
					this.position.x += x * s;
					this.position.y += y * s;
					this.position.z += z * s;
				}
			}
		};

		/**
			Checks wether this sphere and the given sphere are overlapping.
			@param {Physics.BoundingSphere} sphere The sphere to check overlapping against.
			@returns {Boolean} True if the spheres are overlapping, false otherwise.
		*/
		BoundingSphere.prototype.overlaps = function(sphere) {
			var position_diff = new Mathematics.Vector3D();
			var distance_squared = this.position.substract(sphere.position, position_diff).squaredMagnitude();
			return distance_squared < ((this.radious + sphere.radious) * (this.radious + sphere.radious));
		};

		/**
			Returns the volume of this bounding sphere.
			@returns {Number} The volume of the bounding sphere.
		*/
		BoundingSphere.prototype.size = function() {
			return 1.333333 * Math.PI * this.radious * this.radious * this.radious;
		};

		/**
			Returns the growth necessary for the given sphere to fit inside this one.
			@param {Physics.BoundingSphere} sphere The sphere that must fit inside this one.
			@returns {Number} The ammount this sphere must be grown to fit the given sphere inside it.
		*/
		BoundingSphere.prototype.growth = function(sphere) {
			var center_offset = sphere.position.substract(this.position, this.__helperVector);
			var distance = center_offset.squaredMagnitude();
			var radious_diff = sphere.radious - this.radious;
			var radious = 0;

			if ((radious_diff * radious_diff) >= distance) {
				if (this.radious > sphere.radious) {
					radious = this.radious;
				} else {
					radious = sphere.radious;
				}
			} else {
				distance = Math.sqrt(distance);
				radious = (distance + this.radious + sphere.radious) * 0.5;
			}

			return radious * radious - this.radious * this.radious;
		};

		return BoundingSphere;
	})();

	return BoundingSphere;
});
if (typeof define !== 'function') {
	var define = require('amdefine')(module);
}

define('src/primitives',["goom-math"], function(Mathematics) {
	var __hasProp = Object.prototype.hasOwnProperty, __extends = function(child, parent) {
		for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; }
		function ctor() { this.constructor = child; }
		ctor.prototype = parent.prototype;
		child.prototype = new ctor();
		child.__super__ = parent.prototype;
		return child;
	};

	/**
		@namespace holds all the primitive classes used in the physics engine.
	*/
	var Primitives = {};

	/**
		Creates a new Primitive.
		@class Primitive representing an object's collision boundaries.
		@param {Mathematics.RigidBody} body The body related to this primitive.
		@param {Mathematics.Matrix4D} [offset] The offset of this primitive from the body origin.
		@property {Mathematics.RigidBody} body The body related to this primitive.
		@property {Mathematics.Matrix4D} offset The offset of this primitive from the body origin.
		@property {Mathematics.Matrix4D} transformationMatrix The transform resulting from the combination of the rigid body's transform and the pimitive's offset.
		@exports Primitive as Physics.Primitives.Primitive
	*/
	var Primitive = (function() {
		function Primitive(body, offset) {
			this.body = body;
			if (offset === null || offset === undefined) offset = new Mathematics.Matrix4D();
			this.offset = offset.clone();
			this.transformationMatrix = new Mathematics.Matrix4D();
			if (this.body !== null && this.body !== undefined) {
				this.calculateInternalData();
			} else {
				this.transformationMatrix = this.offset;
			}
		}

		/**
			Calculates this primitive's internal data, just the transformation matrix for now.
		*/
		Primitive.prototype.calculateInternalData = function() {
			if (this.body !== null && this.body !== undefined) this.body.transformationMatrix.clone(this.transformationMatrix);
			this.transformationMatrix.data[12] += this.offset.data[12];
			this.transformationMatrix.data[13] += this.offset.data[13];
			this.transformationMatrix.data[14] += this.offset.data[14];
		};

		/**
			Returns the position vector from the body origin.
			@param {Mathematics.Vector3D} destination The vector where result is stored.
			@returns {Mathematics.Vector3D} The position vector from the origin.
		*/
		Primitive.prototype.position = function(destination) {
			return this.transformationMatrix.axisVector(3, destination);
		};

		/**
			Rerturns the axis vector from the transformation matrix.
			@param {Mathematics.Vector3D} destination The vector where result is stored.
			@returns {Mathematics.Vector3D} axis vector.
		*/
		Primitive.prototype.axisVector = function(index, destination) {
			return this.transformationMatrix.axisVector(index, destination);
		};

		Primitives.Primitive = Primitive;
		return Primitive;
	})();

	/**
		Creates a new Sphere.
		@class Primitive representing an object's collision boundaries. This primitive is a sphere.
		@param {Mathematics.RigidBody} body The body related to this primitive.
		@param {Number} radius The radius of the sphere.
		@param {Mathematics.Matrix4D} [offset] The offset of this primitive from the body origin.
		@property {Mathematics.RigidBody} body The body related to this primitive.
		@property {Number} radious The radious of the sphere.
		@property {Mathematics.Matrix4D} offset The offset of this primitive from the body origin.
		@exports Sphere as Physics.Primitives.Sphere
	*/
	var Sphere = (function() {
		__extends(Sphere, Primitives.Primitive);

		function Sphere(body, radious, offset) {
			this.radious = radious;
			Sphere.__super__.constructor.call(this, body, offset);
		}

		Primitives.Sphere = Sphere;
		return Sphere;
	})();

	/**
		Creates a new Plane.
		@class Primitive representing an object's collision boundaries. This primitive is a plane.
		@param {Mathematics.RigidBody} body The body related to this primitive.
		@param {Mathematics.Vector3D} normal The plane normal.
		@param {Number} [offset=0] The offset of this primitive from the body origin.
		@property {Mathematics.RigidBody} body The body related to this primitive.
		@property {Mathematics.Vector3D} normal The plane normal.
		@property {Number} offset The offset of this primitive from the body origin
		@exports Plane as Physics.Primitives.Plane
	*/
	var Plane = (function() {
		__extends(Plane, Primitives.Primitive);

		function Plane(body, normal, offset) {
			this.body = body;
			this.normal = normal;
			this.offset = offset !== null && offset !== undefined ? offset : 0;
		}

		/**
			Calculates this primitive's internal data, which is nothing for the plane.
		*/
		Plane.prototype.calculateInternalData = function() {};
		
		Primitives.Plane = Plane;
		return Plane;
	})();

	/**
		Creates a Box primitive.
		@class Primitive representing an object's collision boundaries. This primitive is a box.
		@param {Mathematics.RigidBody} body The body related to this primitive.
		@param {Mathematics.Vector3D} halfSize A vector representing the size of the box from the origin on each axis.
		@param {Mathematics.Matrix4D} [offset] The offset of this primitive from the body origin.
		@property {Mathematics.RigidBody} body The body related to this primitive.
		@param {Mathematics.Vector3D} halfSize A vector representing the size of the box from the origin on each axis.
		@property {Mathematics.Matrix4D} offset The offset of this primitive from the body origin.
		@exports Box as Physics.Primitives.Box
	*/
	var Box = (function() {
		__extends(Box, Primitives.Primitive);
		
		function Box(body, half_size, offset) {
			Box.__super__.constructor.call(this, body, offset);
			this.halfSize = half_size.clone();
		}

		Primitives.Box = Box;
		return Box;
	})();

	return Primitives;
});
if (typeof define !== 'function') {
	var define = require('amdefine')(module);
}

define('src/intersection_tests',["goom-math", "./primitives"], function(Mathematics) {
	/**
		@namespace Holds interesection tests used for early-out checks.
	*/
	var IntersectionTests = {};
	IntersectionTests.__helperVector = new Mathematics.Vector3D();

	/**
		Checks whether the given primitives intersect or not.
		@param {Physics.Box} box The box to check.
		@param {Physics.Plane} plane The plane to check.
		@returns {Boolean} true if they intersect, false otherwise.
	*/
	IntersectionTests.boxAndHalfSpace = function(box, plane) {
		var box_halfsize = box.halfSize;
		var projected_radious = box_halfsize.x * Math.abs(plane.normal.dotProduct(box.axisVector(0, IntersectionTests.__helperVector))) + box_halfsize.y * Math.abs(plane.normal.dotProduct(box.axisVector(1, IntersectionTests.__helperVector))) + box_halfsize.z * Math.abs(plane.normal.dotProduct(box.axisVector(2, IntersectionTests.__helperVector)));
		var box_distance = plane.normal.dotProduct(box.position(IntersectionTests.__helperVector)) - projected_radious;
		return box_distance <= plane.offset;
	};

	return IntersectionTests;
});
if (typeof define !== 'function') {
	var define = require('amdefine')(module);
}

define('src/bounding_volume_hierarchy_node',["goom-math", "./bounding_sphere", "./rigid_body"], function(Mathematics, BoundingSphere) {
	/**
		Creates a new BoundingVolumeHierarchyNode.
		@class This class is used in the BV hirarchies to build the hierarchies.
		@exports BoundingVolumeHierarchyNode as Physics.BoundingVolumeHierarchyNode
		@property {Physics.BoundingVolumeHierarchyNode} parent This node's parent.
		@params {Physics.BoundingSphere} volume A bounding volume for the new node.
		@params {Physics.RigidBody} body A rigid body to be stored in the new node.
		@property {Array} children BoundingVolumeHierarchyNode array holding two children.
		@property {Physics.BoundingSphere} volume The bounding volume class.
		@property {Physics.RigidBody} body If this is a leaf node, it hols the body in this node.
		@property {Physics.BoundingVolumeHierarchyNode} parent This node's parent.
	*/
	var BoundingVolumeHierarchyNode = (function() {
		function BoundingVolumeHierarchyNode(parent, body, volume) {
			this.parent = parent !== null && parent !== undefined? parent : null;
			this.body = body !== null && body !== undefined? body : null;
			this.volume = volume !== null && volume !== undefined? volume : new BoundingSphere();
			if (this.body !== null && this.body !== undefined) this.body.boundingVolumeHierarchyNode = this;
			this.children = new Array(2);
		}

		/**
			Checks wether the node is at the bottom of the hierarchy. If it is a leaf,
			it will hold a body.
			@returns {Boolean} true if the node is a leaf node, false otherwise.
		*/
		BoundingVolumeHierarchyNode.prototype.isLeaf = function() {
			return this.body !== null && this.body !== undefined;
		};

		/**
			Checks wether the node is at the top of the hierarchy. If it is not a root node,
			it will hold a parent node.
			@returns {Boolean} true if the node is a root node, false otherwise.
		*/
		BoundingVolumeHierarchyNode.prototype.isRoot = function() {
			return this.parent === null || this.parent === undefined;
		};

		/**
			Checks whether a node is overlapping another.
			@params {Physics.BoundingVolumeHierarchyNode} The other BoundingVolumeHierarchyNode to
			check against.
			@returns {Boolean} true if node is overlapping the other node, false otherwise.
		*/
		BoundingVolumeHierarchyNode.prototype.overlaps = function(other) {
			return this.volume.overlaps(other.volume);
		};

		/**
			Gets an array with the potential contacts between the node's children upto the given
			limit.
			@params {Array} contacts Array holding the possible contacts, where the newly found possible contacts will be pushed.
			@params {Number} [limit=1000] The maximum number of possible contacts.
			@returns {Number} The ammount of newly found contacts.
		*/
		BoundingVolumeHierarchyNode.prototype.potentialContacts = function(contacts, limit) {
			if (limit === null || limit === undefined) limit = 1000;
			if (this.isLeaf() || limit === 0) return 0;

			return this.children[0].potentialContactsWith(this.children[1], contacts, limit);
		};

		/**
			Gets an array with the potential contacts between this node and the given node, upto
			the given limit.
			@params {Physics.BoundingVolumeHierarchyNode} other The node to check against.
			@params {Array} contacts Array holding the possible contacts, where the newly found possible contacts will be pushed.
			@params {Number} limit The maximum number of possible contacts
			@returns {Number} The ammount of newly found contacts.
		*/
		BoundingVolumeHierarchyNode.prototype.potentialContactsWith = function(other, contacts, limit) {
			//No contacts if the bonunding volumes are not overlapping or no more of them fit.
			if (!this.overlaps(other) || limit === 0) return 0;
			//If both nodes are leaf nodes, their bodies are potentially in contact.
			if (this.isLeaf() && other.isLeaf()) {
				contacts.push([this.body, other.body]); 
				//TODO: There has to be a better way to store this than creating an array per contact.
				return 1;
			}

			var num_contacts = 0;
			if (other.isLeaf() || (!this.isLeaf() && (this.volume.size() >= other.volume.size()))) {
				//Recurse into the first child.
				num_contacts = this.children[0].potentialContactsWith(other, contacts, limit);
				//If there is enough space for contacts, recurse into the other child.
				if (limit > num_contacts) {
					num_contacts += this.children[1].potentialContactsWith(other, contacts, limit - num_contacts);
				}
			} else {
				//Recurse the other node's first child.
				num_contacts = this.potentialContactsWith(other.children[0], contacts, limit);
				//If there is enough space for contacts, recurse the other child.
				if (limit > num_contacts) {
					num_contacts += this.potentialContactsWith(other.children[1], contacts, limit - num_contacts);
				}
			}
			return num_contacts;
		};

		/**
			Calculates the size of the bounding volume to hold its children.
		*/
		BoundingVolumeHierarchyNode.prototype.calculateBoundingVolume = function() {
			if (!this.isLeaf) {
				this.volume.fitSpheres(this.children[0].volume, this.children[1].volume);
			}
		};

		/**
			Inserts a new volume and body into the bounding volume hierarchy.
			@params {Physics.RigidBody} body A rigid body to be stored in the new node.
			@params {Physics.BoundingVolume} volume A bounding volume for the new node.
		*/
		BoundingVolumeHierarchyNode.prototype.insert = function(body, volume) {
			//If this is a leaf node, insert the body and volume as a child node, and move this node down as a child.
			if (this.isLeaf()) {
				//TODO: Can we avoid creating these?
				this.children[0] = new BoundingVolumeHierarchyNode(this, this.body, new BoundingSphere(this.volume.position, this.volume.radious));
				this.children[1] = new BoundingVolumeHierarchyNode(this, body, volume);
				this.body = null;
				this.calculateBoundingVolume();
				return;
			}

			//Otherwise, we need to calculate which child keeps the body.
			if (this.children[0].volume.growth(volume) < this.children[1].volume.growth(volume)) {
				this.children[0].insert(body, volume);
			} else {
				this.children[1].insert(body, volume);
			}
		};

		/**
			Frees this node, depending on the second value all the nodes down the tree will be dereferenced (which should be freed from memory when the garbage collector kicks in).
			@param {Boolean} [reestructure_tree=true] Wether the tree should be automatically reestrucutred or not, only applies when the node is 
			not a root node.
		*/
		BoundingVolumeHierarchyNode.prototype.free = function(reestructure_tree) {
			if (reestructure_tree === null || reestructure_tree === undefined) reestructure_tree = true;

			if (!this.isRoot() && reestructure_tree) {
				//Get this node's sibling for tree reestructure.
				var sibling = this.parent.children[0] === this ? this.parent.children[1] : this.parent.children[0];
				//Write the sibling's data to into the parent.
				this.parent.volume = sibling.volume;
				this.parent.body = sibling.body;

				if (this.parent.body !== null && this.parent.body !== undefined) {
					this.parent.body.boundingVolumeHierarchyNode = this.parent;
				}

				if (sibling.children[0] !== null && sibling.children[0] !== undefined) {
					this.parent.children[0] = sibling.children[0];
					this.parent.children[0].parent = this.parent;
				} else
					this.parent.children[0] = null;

				if (sibling.children[1] !== null && sibling.children[1] !== undefined) {
					this.parent.children[1] = sibling.children[1];
					this.parent.children[1].parent = this.parent;
				} else
					this.parent.children[1] = null;
			}

			//The following code is not necessary when the node has no children
			if (this.isLeaf()) return;
			//Freeing the children
			this.children[0].free(false);
			this.children[1].free(false);
			this.children[0] = null;
			this.children[1] = null;
		};

		/**
			This method should be called when the position of the bounding volume has changed, it will move the node to the 
			proper level if it is necessary.
		*/
		BoundingVolumeHierarchyNode.prototype.updateHierarchy = function() {
			//Update the volume's position
			this.body.position.clone(this.volume.position);

			if (!this.isRoot()) {
				//Remove this node from the hierarchy
				this.free();
				//Attempt reinsertion
				this.parent.reinsert(this.body, this.volume);
			}
		};

		/**
			Attempts to insert a node back into the hierarchy from one of the lower ends.
			@params {Physics.RigidBody} body A rigid body to be stored in the new node. 
			@params {Physics.BoundingVolume} volume A bounding volume for the new node.
		*/
		BoundingVolumeHierarchyNode.prototype.reinsert = function(body, volume) {
			if ((this.volume.growth(volume) <= 0) || this.isRoot()) {
				//Found the insertion point!
				this.insert(body, volume);
			} else {
				//Keep looking up the tree
				this.parent.reinsert(body, volume);
			}
		};

		return BoundingVolumeHierarchyNode;
	})();
	return BoundingVolumeHierarchyNode;
});
if (typeof define !== 'function') {
	var define = require('amdefine')(module);
}

define('src/rigid_body',["goom-math", "./primitives", "./bounding_volume_hierarchy_node"], function(Mathematics, Primitives) {
	/**
		Creates a RigidBody.
		@class This is the basic rigid body class used for physics simulations.
		@exports RigidBody as Physics.RigidBody
		@property {Number} inverseMass The inverse mass of the rigid body.
		@property {Mathematics.Vector3D} position The position of the object in world space.
		@property {Mathematics.Quaternion} orientation Angular orientation of the body.
		@property {Mathematics.Vector3D} velocity The velocity of the rigid body in world space.
		@property {Mathematics.Vector3D} angular_velocity Angular velocity (or rotation) of the body in world space.
		@property {Mathematics.Matrix4D} transformationMatrix The object's transformation matrix. Cached
		for performance reasons.
		@property {Mathematics.Matrix3D} inverseInertiaTensor The inverse of the body's inertia tensor.
		@property {Mathematics.Matrix3D} inverseInertiaTensorWorld The inverse of the body's inertia
		tensor in world coordinates.
		@property {Mathematics.Mathematics.Vector3D} lastFrameAcceleration The acceleration in the previous frame.
		@property {Mathematics.Mathematics.Vector3D} acceleration The acceleration in this frame.
		@property {Mathematics.Vector3D} accumulatedForce The total accumulated forces to this body.
		@property {Mathematics.Vector3D} accumulatedTorque The total accumulated torque to this body.
		@property {Boolean} isAwake Whether the body is awake or not.
		@property {Boolean} canSleep Wether this body is allowed to sleep or not, some bodies can never fall asleep.
		@property {Number} motion Ammount of motion of the body. Used to put bodies to sleep.
		@property {Array} primitives The list of primitives in this body, used for narrow phase collision detection.
		@property {Physics.BoundingVolumeHierarchyNode} boundingVolumeHierarchyNode BVHNodes are used in broad-phase
		collision detection, rigid bodies will hold a reference to the one holding them in order to notify them on position changes.
		@property {Mathematics.Vector3D} __helperVector This vector is used in a few functions as a local variable,
			it is defined as a class variable to avoid the creation of objects at runtime.
		@param {Mathematics.Vector3D} [position=(0,0,0)] The position of the object in world space.
		@param {Mathematics.Quaternion} [orientation=(1,0,0,0)] Angular orientation of the body.
		@param {Mathematics.Vector3D} [velocity=(0,0,0)] The velocity of the rigid body in world space.
		@param {Mathematics.Vector3D} [angular_velocity=(0,0,0)] Angular velocity (or rotation) of the body in world space.
	*/
	var RigidBody = (function() {
		function RigidBody(position, orientation, velocity, angular_velocity) {
			this.position = position !== null && position !== undefined? position: new Mathematics.Vector3D();
			this.orientation = orientation !== null && orientation !== undefined? orientation: new Mathematics.Quaternion();
			this.velocity = velocity !== null && velocity !== undefined? velocity: new Mathematics.Vector3D();
			this.angular_velocity = angular_velocity !== null && angular_velocity !== undefined? angular_velocity: new Mathematics.Vector3D();
			this.inverseMass = 0;
			this.acceleration = new Mathematics.Vector3D();
			this.lastFrameAcceleration = new Mathematics.Vector3D();
			this.transformationMatrix = new Mathematics.Matrix4D();
			this.inverseInertiaTensor = new Mathematics.Matrix3D();
			this.inverseInertiaTensorWorld = new Mathematics.Matrix3D();
			this.accumulatedForce = new Mathematics.Vector3D();
			this.accumulatedTorque = new Mathematics.Vector3D();
			this.isAwake = true;
			this.canSleep = true;
			this.motion = 0;
			this.boundingVolumeHierarchyNode = null;
			this.primitives = [];
			this.calculateInternalData();
			this.__helperVector = new Mathematics.Vector3D();
		}

		/**
			Sets the inertia tensor for this body, stored in the inverse inertia tensor
			variable.
			@param {Mathematics.Matrix3D} inertia_tensor The inertia tensor for this body.
		*/
		RigidBody.prototype.setInertiaTensor = function(inertia_tensor) {
			inertia_tensor.inverse(this.inverseInertiaTensor);
		};

		/**
			Sets the inertia tensor's coefficients to this body's inertial tensor.
			@param {Number} coeff00 The coefficient for the 00 element of the inertia tensor.
			@param {Number} coeff11 The coefficient for the 11 element of the inertia tensor.
			@param {Number} coeff22 The coefficient for the 22 element of the inertia tensor.
		*/
		RigidBody.prototype.setInertiaTensorCoefficients = function(coeff00, coeff11, coeff22) {
			var inertia_tensor = new Mathematics.Matrix3D();
			inertia_tensor.setDiagonal(coeff00, coeff11, coeff22);
			inertia_tensor.inverse(this.inverseInertiaTensor);
		};

		/**
			Calculates the internal data from the state data. Should be called after the
			body's state is altered directly.
		*/
		RigidBody.prototype.calculateInternalData = function() {
			this.orientation.normalize();
			//Calculate the transform matrix for this body.
			this.transformationMatrix.makeFromPositionAndOrientation(this.position, this.orientation);
			//Calculate the inertia tensor in world space.
			this.transformationMatrix.transformMatrix3D(this.inverseInertiaTensor, this.inverseInertiaTensorWorld);
			//Update the primitives in this body.
			_ref = this.primitives;
			for (var i = 0, len = _ref.length; i < len; i++) {
				primitive = _ref[i];
				primitive.calculateInternalData();
			}

			//Notify the BVH it needs to be updated.
			if (this.boundingVolumeHierarchyNode !== null) this.boundingVolumeHierarchyNode.updateHierarchy();
		};

		/*
			Wakes this body up.
		*/
		RigidBody.prototype.wakeUp = function() {
			this.isAwake = true;
			this.motion = 2 * RigidBody.SLEEP_EPSILON;
		};

		/*
			Make this body go to sleep.
		*/
		RigidBody.prototype.sleep = function() {
			this.isAwake = false;
			this.velocity.zero();
			this.angular_velocity.zero();
		};

		/**
			Applies a force expressed in world coordinates to this body.
			@param {Mathematics.Vector3D} force The force to be applied to this body.
		*/
		RigidBody.prototype.applyForce = function(force) {
			this.accumulatedForce.add(force);
			this.wakeUp();
		};

		/**
			Applies a force to the given point in the body, both the force and the point are
			expected to be given in world coordinates. Because the force is not applied to
			the center of gravity, it may be split into a force and a torque.
			@param {Mathematics.Vector3D} force The force to be applied to this body.
			@param {Mathematics.Vector3D} point The point in world coordinates where the force is applied.
		*/
		RigidBody.prototype.applyForceAtPoint = function(force, point) {
			point.substract(this.position, this.__helperVector);
			this.accumulatedForce.add(force);
			this.accumulatedTorque.add(this.__helperVector.crossProduct(force));
			this.wakeUp();
		};

		/**
			Applies a force to the gien point in the body, both the force is expected to be
			given in world coordinates, but the point in object coordinates.
			@param {Mathematics.Vector3D} force The force to be applied to this body.
			@param {Mathematics.Vector3D} point The point in object coordinates where the force is applied.
		*/
		RigidBody.prototype.applyForceAtBodyPoint = function(force, point) {
			this.applyForceAtPoint(force, this.transformationMatrix.transformVector(point, this.__helperVector));
		};

		/**
			Applies a torque expressed in world coordinates to this body.
			@param {Mathematics.Vector3D} torque The torque to be applied to this body.
		*/
		RigidBody.prototype.applyTorque = function(torque) {
			this.accumulatedTorque.add(torque);
			this.wakeUp();
		};

		/**
			Clears the total accumulated forces and torque.
		*/
		RigidBody.prototype.clear = function() {
			this.accumulatedForce.zero();
			this.accumulatedTorque.zero();
		};

		/**
			Retuns whether this body has a finite mass or not.
			@returns {Boolean} true if it has a finite mass, false otherwise.
		*/
		RigidBody.prototype.hasFiniteMass = function() {
			return this.inverseMass >= 0;
		};

		/**
			Returns the mass of this body.
			@returns {Number} mass of this body.
		*/
		RigidBody.prototype.getMass = function() {
			if (this.inverseMass === 0) return Number.MAX_VALUE;
			return 1 / this.inverseMass;
		};

		/**
			Sets the mass of this body.
			@param {Number} mass The mass of this body.
		*/
		RigidBody.prototype.setMass = function(mass) {
			if (mass === 0) this.inverseMass = Number.MAX_VALUE;
			this.inverseMass = 1 / mass;
		};

		/**
			Adds and creates a primitive from the given description.
			@param primitive_data A json object or an array of json objects describing the primitive to be added.
			@throws An exception when the primitive type is not known.
		*/
		RigidBody.prototype.addPrimitives = function(primitive_data) {
			//If Primitives is an array, it means we have to add more than one primitive, otherwise, just one primitive.
			if (!(primitive_data instanceof Array)) {
				switch (primitive_data.type.toLowerCase()) {
					case 'sphere':
						this.primitives.push(new Primitives.Sphere(this, primitive_data.radious, primitive_data.offset !== null && primitive_data.offset !== undefined? (new Mathematics.Matrix4D()).set(primitive_data.offset): null));
						break;
					case 'box':
						this.primitives.push(new Primitives.Box(this, new Mathematics.Vector3D(primitive_data.halfSize.x, primitive_data.halfSize.y, primitive_data.halfSize.z), primitive_data.offset !== null && primitive_data.offset !== undefined? (new Mathematics.Matrix4D()).set(primitive_data.offset): null));
						break;
					default:
						throw "Unkwnown primitive type";
				}
				return;
			}

			var one_primitive_data, i, len;
			for (i = 0, len = primitive_data.length; i < len; i++) {
				one_primitive_data = primitive_data[i];
				switch (one_primitive_data.type.toLowerCase()) {
					case 'sphere':
						this.primitives.push(new Primitives.Sphere(this, one_primitive_data.radious, one_primitive_data.offset !== null && primitive_data.offset !== undefined? (new Mathematics.Matrix4D()).set(one_primitive_data.offset) : null));
						break;
					case 'box':
						this.primitives.push(new Primitives.Box(this, new Mathematics.Vector3D(one_primitive_data.halfSize.x, one_primitive_data.halfSize.y, one_primitive_data.halfSize.z), one_primitive_data.offset !== null && primitive_data.offset !== undefined? (new Mathematics.Matrix4D()).set(one_primitive_data.offset): null));
						break;
					default:
						throw "Unkwnown primitive type";
				}
			}
		};

		/**
			Integrates the body forward in time by the given ammount.
			@param {Number} duration The ammount of time to step forward.
		*/
		RigidBody.prototype.integrate = function(duration) {
			if (!this.isAwake) return;

			//Calculate linear acceleration
			this.acceleration.clone(this.lastFrameAcceleration);
			this.lastFrameAcceleration.add(this.accumulatedForce.scale(this.inverseMass, this.__helperVector));
			//Calculate the angular acceleration from toques.
			this.inverseInertiaTensorWorld.transformVector(this.accumulatedTorque, this.__helperVector);
			//Update velocities
			this.angular_velocity.add(this.__helperVector.scale(duration));
			this.velocity.add(this.lastFrameAcceleration.scale(duration, this.__helperVector));
			//Impose drag
			this.velocity.scale(Math.pow(RigidBody.LINEAR_DAMPING, duration));
			this.angular_velocity.scale(Math.pow(RigidBody.ANGULAR_DAMPING, duration));
			//Clear forces for the next integration step
			this.clear();

			//Update the kinetic energy and possibly put the body to sleep
			if (this.canSleep) {
				var current_motion = this.velocity.squaredMagnitude() + this.angular_velocity.squaredMagnitude();
				var bias = Math.pow(0.5, duration);
				this.motion = bias * this.motion + (1 - bias) * current_motion;

				if (this.motion < RigidBody.SLEEP_EPSILON) {
					this.sleep();
					return;
				} else if (this.motion > 5 * RigidBody.SLEEP_EPSILON) {
					this.motion = 5 * RigidBody.SLEEP_EPSILON;
				} else if (current_motion < RigidBody.SLEEP_EPSILON) {
					return;
				}
			}

			//Update positions
			this.position.add(this.velocity.scale(duration, this.__helperVector));
			this.orientation.addVector(this.angular_velocity.scale(duration, this.__helperVector));
			//Update derived data
			this.calculateInternalData();
		};

		/**
			@static
			This value is used to limit the energy under which a body will be set to sleep.
		*/
		RigidBody.SLEEP_EPSILON = 0.2;

		/**
			@static
			This is the damping coefficient used for linear velocity, it will speed down linear velocity with time.
		*/
		RigidBody.LINEAR_DAMPING = 0.9999;

		/**
			@static
			This is the damping coefficient used for angular velocity, it will speed down angular velocity with time.
		*/
		RigidBody.ANGULAR_DAMPING = 0.9999;
		return RigidBody;
	})();
	return RigidBody;
});
if (typeof define !== 'function') {
	var define = require('amdefine')(module);
}

define('src/contact',["goom-math", "./rigid_body"], function(Mathematics) {
	/**
		Creates a new Contact.
		@class Holds the information required to resolve contacts.
		@param {Mathematics.Vector3D} [point=(0,0,0)] The position of the contact in world coordinates.
		@param {Mathematics.Vector3D} [normal=(0,0,0)] The direction of the contact in world coordinates.
		@param {Number} [penetration=0] The depth of penetration at the contact point.
		@property {Mathematics.Vector3D} point The position of the contact in world coordinates.
		@property {Mathematics.Vector3D} normal The direction of the contact in world coordinates.
		@property {Mathematics.Vector3D} vector The velocity of the contact in world coordinates.
		@property {Number} penetration The depth of penetration at the contact point.
		@property {Array} bodies Holds references to the bodies in contact.
		@property {Number} restitution Restitution coeficient in this contact.
		@property {Number} friction Friction coeficient in this contact.
		@property {Array} relativeContactPositions Array holding two Vectors, each holding the contact position relative to each body.
		@property {Mathematics.Matrix3D} toWorld Matrix holding the contact to world coordinate changes.
		@property {Number} desiredDeltaVelocity The desired change in velocity for contact resolution.
		@exports Contact as Physics.Contact
	*/
	var Contact = (function() {
		function Contact(point, normal, penetration) {
			this.penetration = penetration !== null && penetration !== undefined ? penetration : 0;
			this.point = point === null || point === undefined? new Mathematics.Vector3D() : point.clone();
			this.normal = normal === null || point === undefined ? new Mathematics.Vector3D() : normal.clone();
			this.bodies = new Array(2);
			this.relativeContactPositions = new Array(2);
			this.relativeContactPositions[0] = new Mathematics.Vector3D();
			this.relativeContactPositions[1] = new Mathematics.Vector3D();
			this.desiredDeltaVelocity = 0;
			this.velocity = new Mathematics.Vector3D();
			this.__helperVector = new Mathematics.Vector3D();
			this.__contactTangent = new Array(2);
			this.__contactTangent[0] = new Mathematics.Vector3D();
			this.__contactTangent[1] = new Mathematics.Vector3D();
			this.toWorld = new Mathematics.Matrix3D();
		}

		/**
			Sets the data related to the bodies in the collision.
			@param {Physics.RigidBody} first_body The first body in the collision.
			@param {Physics.RigidBody} second_body The second body in the collison.
			@param {Number} restitution Restitution coeficient in this contact.
			@param {Number} friction Friction coeficient in this contact.
		*/
		Contact.prototype.setContactData = function(first_body, second_body, restitution, friction) {
			this.bodies[0] = first_body;
			this.bodies[1] = second_body;
			this.restitution = restitution;
			this.friction = friction;
		};

		/**
			Swaps the position of the bodies in this contact, updating the contact normal accordingly.
			@inner
		*/
		Contact.prototype.__swapBodies = function() {
			this.normal.scale(-1);
			var tmp = this.bodies[0];
			this.bodies[0] = this.bodies[1];
			this.bodies[1] = tmp;
		};

		/**
			Updates the awake state of the rigid bodies. A body will be woken up if it is in contact with a body that is awake.
		*/
		Contact.prototype.matchAwakeState = function() {
			//Contacts with the world don't wake up bodies
			if (this.bodies[1] === null || this.bodies[1] === undefined) return;
			//If one of the bodies is awake and the other asleep
			if (this.bodies[0].isAwake ^ this.bodies[1].isAwake) {
				if (this.bodies[0].isAwake) this.bodies[0].wakeUp();
				else this.bodies[1].wakeUp();
			}
		};

		/**
			Calculates the internal value for the desired delta velocity.
			@param {Number} duration The duration of the previous integration step.
		*/
		Contact.prototype.calculateDesiredDeltaVelocity = function(duration) {
			var scaled_contact = this.normal.scale(duration, this.__helperVector);
			var velocity_from_acceleration = 0;

			//Calculate the acceleration induced velocity accumulated this frame
			if (this.bodies[0].isAwake) {
				velocity_from_acceleration = this.bodies[0].lastFrameAcceleration.dotProduct(scaled_contact);
			}

			if ((this.bodies[1] !== null && this.bodies[1] !== undefined) && this.bodies[1].isAwake) {
				velocity_from_acceleration -= this.bodies[1].lastFrameAcceleration.dotProduct(scaled_contact);
			}

			//If velocity is too slow, limit restitution
			var local_restitution = this.restitution;
			if (Math.abs(this.velocity.x) < Contact.MIN_VELOCITY) {
				local_restitution = 0;
			}
			
			//Calculate the bounce velocity with the removed acceleration velocity.
			this.desiredDeltaVelocity = -this.velocity.x - local_restitution * (this.velocity.x - velocity_from_acceleration);
		};

		/**
			Calculate internal data from state data.
			@param {Number} duration The duration of the previous integration step.
		*/
		Contact.prototype.calculateInternalData = function(duration) {
			var s;
			//Make the first body be non-null
			if (this.bodies[0] === null || this.bodies[0]  === undefined) this._swapBodies();
			//Calculate contact basis
			if (Math.abs(this.normal.x) > Math.abs(this.normal.y)) {
				//Scaling factor to ensure results are normalized.
				s = 1 / Math.sqrt(this.normal.z * this.normal.z + this.normal.x * this.normal.x);
				//The new x-axis is at right angles to the world y-axis
				this.__contactTangent[0].x = this.normal.z * s;
				this.__contactTangent[0].y = 0;
				this.__contactTangent[0].z = -this.normal.x * s;
				//The new y-axis is at right angles to the new x and z axes
				this.__contactTangent[1].x = this.normal.y * this.__contactTangent[0].x;
				this.__contactTangent[1].y = this.normal.z * this.__contactTangent[0].x - this.normal.x * this.__contactTangent[0].z;
				this.__contactTangent[1].z = -this.normal.y * this.__contactTangent[0].x;
			} else {
				//Scaling factor to ensure results are normalized.
				s = 1 / Math.sqrt(this.normal.z * this.normal.z + this.normal.y * this.normal.y);
				//The new x-axis is at right angles to the world x-axis
				this.__contactTangent[0].x = 0;
				this.__contactTangent[0].y = -this.normal.z * s;
				this.__contactTangent[0].z = this.normal.y * s;
				//The new y-axis is at right angles to the new x and z axes
				this.__contactTangent[1].x = this.normal.y * this.__contactTangent[0].z - this.normal.z * this.__contactTangent[0].y;
				this.__contactTangent[1].y = -this.normal.x * this.__contactTangent[0].z;
				this.__contactTangent[1].z = this.normal.x * this.__contactTangent[0].y;
			}

			this.toWorld.makeFromVectors(this.normal, this.__contactTangent[0], this.__contactTangent[1]);
			//Store the position of the contact relative to each body
			this.point.substract(this.bodies[0].position, this.relativeContactPositions[0]);
			if (this.bodies[1] !== null && this.bodies[1] !== undefined) {
				this.point.substract(this.bodies[1].position, this.relativeContactPositions[1]);
			}

			//Calculate relative velocity of the bodies at contact point
			this.relativeContactPositions[0].crossProduct(this.bodies[0].angular_velocity, this.velocity);
			this.velocity.add(this.bodies[0].velocity);
			//Calculate the ammount of velocity due to forces without reactions
			var acceleration_velocity = this.bodies[0].lastFrameAcceleration.scale(duration, this.__helperVector);
			//We are only interested in planar acceleration, so we ignore acceleration in the contact normal direction
			acceleration_velocity.x = 0;
			this.velocity.add(acceleration_velocity);

			if (this.bodies[1] !== null && this.bodies[1] !== undefined) {
				//Do the same for the second body
				var second_velocity = this.relativeContactPositions[1].crossProduct(this.bodies[1].angular_velocity, this.__helperVector);
				second_velocity.add(this.bodies[1].velocity);
				//Add the velocity due to the second body to the total contact velocity
				this.velocity.substract(second_velocity);
				//Calculate the ammount of velocity due to forces without reactions
				acceleration_velocity = this.bodies[1].lastFrameAcceleration.scale(duration, this.__helperVector);
				//We are only interested in plannar acceleration, so we ignore acceleration in the contact normal direction
				acceleration_velocity.x = 0;
				//Add the velocity due to the second body's acceleration to the total contact velocity
				this.velocity.substract(acceleration_velocity);
			}

			//Convert velocity to contact coordinates
			this.toWorld.transformTransposeVector(this.velocity);
			//Calculate the desired change in velocity for resolution
			this.calculateDesiredDeltaVelocity(duration);
		};

		/**
			Performs a inertia weighted penetration resolution of this contact.
			@param {Array} linear_change Array holding vectors representing the linear position change for each body.
			@param {Array} angular_change Array holding vectors representing the angular position change for each body.
			@param {Number} penetration Ammount of penetration to resolve.
		*/
		/*Contact.prototype.resolvePosition = function(linear_change, angular_change, penetration) {
		var angular_inertia, angular_inertia_world, angular_move, linear_inertia, linear_move, max_magnitude, projection, target_angular_direction, total_inertia, total_move;
		total_inertia = 0;
		angular_inertia = [];
		linear_inertia = [];
		angular_inertia_world = this.normal.crossProduct(this.relativeContactPositions[0], new Math.Vector3D());
		angular_inertia_world.transformByMatrix(this.bodies[0].inverseInertialTensorWorld);
		this.relativeContactPositions[0].crossProduct(angular_inertia_world, angular_inertia_world);
		angular_inertia.push(angular_inertia_world.dotProduct(this.normal));
		linear_inertia.push(this.bodies[0].inverseMass);
		total_inertia += angular_inertia[0] + linear_inertia[0];
		if (this.bodies[1] != null) {
		angular_inertia_world = this.normal.crossProduct(this.relativeContactPositions[1], new Math.Vector3D());
		angular_inertia_world.transformByMatrix(this.bodies[1].inverseInertialTensorWorld);
		this.relativeContactPositions[1].crossProduct(angular_inertia_world, angular_inertia_world);
		angular_inertia.push(angular_inertia_world.dotProduct(this.normal));
		linear_inertia.push(this.bodies[1].inverseMass);
		total_inertia += angular_inertia[1] + linear_inertia[1];
		}
		angular_move = [];
		linear_move = [];
		angular_move.push(penetration * (angular_inertia[0] / total_inertia));
		linear_move.push(penetration * (linear_inertia[0] / total_inertia));
		projection = (this.normal.scale(-this.relativeContactPositions[0].dotProduct(this.normal), new Math.Vector3D())).add(this.relativeContactPositions[0]);
		max_magnitude = Contact.ANGULAR_LIMIT * projection.magnitude();
		if (angular_move[0] < -max_magnitude) {
		total_move = angular_move[0] + linear_move[0];
		angular_move[0] = -max_magnitude;
		linear_move[0] = total_move - angular_move[0];
		} else if (angular_move[0] > max_magnitude) {
		total_move = angular_move[0] + linear_move[0];
		angular_move[0] = max_magnitude;
		linear_move[0] = total_move - angular_move[0];
		}
		if (angular_move[0] === 0) {
		angular_change[0].zero();
		} else {
		target_angular_direction = this.normal.crossProduct(this.relativeContactPositions[0], new Math.Vector3D());
		angular_change[0] = target_angular_direction.transformByMatrix(this.bodies[0].inverseInertialTensorWorld).scale(angular_move[0] / angular_inertia[0]);
		}
		linear_change[0] = this.normal.scale(linear_move[0], new Math.Vector3D());
		this.bodies[0].position.add(linear_change[0]);
		this.bodies[0].orientation.addVector(angular_change[0]);
		if (!this.bodies[0].isAwake) {
		this.bodies[0].calculateInternalData();
		}
		if (this.bodies[1] != null) {
		angular_move.push(-penetration * (angular_inertia[1] / total_inertia));
		linear_move.push(-penetration * (linear_inertia[1] / total_inertia));
		projection = (this.normal.scale(-this.relativeContactPositions[1].dotProduct(this.normal), new Math.Vector3D())).add(this.relativeContactPositions[1]);
		max_magnitude = Contact.ANGULAR_LIMIT * projection.magnitude();
		if (angular_move[1] < -max_magnitude) {
		total_move = angular_move[1] + linear_move[1];
		angular_move[1] = -max_magnitude;
		linear_move[1] = total_move - angular_move[1];
		} else if (angular_move[1] > max_magnitude) {
		total_move = angular_move[1] + linear_move[1];
		angular_move[1] = max_magnitude;
		linear_move[1] = total_move - angular_move[1];
		}
		if (angular_move[1] === 0) {
		angular_change[1].zero();
		} else {
		target_angular_direction = this.normal.crossProduct(this.relativeContactPositions[1], new Math.Vector3D());
		angular_change[1] = target_angular_direction.transformByMatrix(this.bodies[1].inverseInertialTensorWorld).scale(angular_move[1] / angular_inertia[1]);
		}
		linear_change[1] = this.normal.scale(linear_move[1], new Math.Vector3D());
		this.bodies[1].position.add(linear_change[1]);
		this.bodies[1].orientation.addVector(angular_change[1]);
		if (!this.bodies[1].isAwake) {
		this.bodies[1].calculateInternalData();
		}
		}
		};*/
		/**
		Performs a inertia weighted impulse resolution of this contact.
		@param {Array} velocity_change Array holding the velocity change for each body.
		@param {Array} rotation_change Array holding the rotation change for each body.
		*/
		/*Contact.prototype.resolveVelocity = function(velocity_change, rotation_change) {
		var delta_velocity, delta_velocity_world, impulse, impulsive_torque;
		impulse = new Math.Vector3D();
		if (this.friction === 0) {
		delta_velocity_world = this.normal.crossProduct(this.relativeContactPositions[0], new Math.Vector3D());
		delta_velocity_world.transformByMatrix(this.bodies[0].inverseInertialTensorWorld);
		this.relativeContactPositions[0].crossProduct(delta_velocity_world, delta_velocity_world);
		delta_velocity = delta_velocity_world.dotProduct(this.normal);
		delta_velocity += this.bodies[0].inverseMass;
		if (this.bodies[1] != null) {
		delta_velocity_world = this.normal.crossProduct(this.relativeContactPositions[1], new Math.Vector3D());
		delta_velocity_world.transformByMatrix(this.bodies[1].inverseInertialTensorWorld);
		this.relativeContactPositions[1].crossProduct(delta_velocity_world, delta_velocity_world);
		delta_velocity += delta_velocity_world.dotProduct(this.normal);
		delta_velocity += this.bodies[1].inverseMass;
		}
		impulse.set(this.desiredDeltaVelocity / delta_velocity, 0, 0);
		}

		impulse.transformByMatrix(this.toWorld);
		impulsive_torque = impulse.crossProduct(this.relativeContactPositions[0], new Math.Vector3D());
		impulsive_torque.transformByMatrix(this.bodies[0].inverseInertialTensorWorld, rotation_change[0]);
		impulse.scale(this.bodies[0].inverseMass, velocity_change[0]);
		this.bodies[0].rotation.add(rotation_change[0]);
		this.bodies[0].velocity.add(velocity_change[0]);
		if (this.bodies[1] != null) {
		impulse.scale(-1);
		impulse.crossProduct(this.relativeContactPositions[1], impulsive_torque);
		impulsive_torque.transformByMatrix(this.bodies[1].inverseInertialTensorWorld, rotation_change[1]);
		impulse.scale(this.bodies[1].inverseMass, velocity_change[1]);
		this.bodies[1].rotation.add(rotation_change[1]);
		this.bodies[1].velocity.add(velocity_change[1]);
		}

		};*/
		
		/**
			@static
			The miniumum velocity for contact resolution, if the velocity is smaller restitution will be limited.
		*/
		Contact.MIN_VELOCITY = 0.25;
		/**
			@static
			Angular limit used for angular position resolution.
		*/
		Contact.ANGULAR_LIMIT = 0.2;
		return Contact;
	})();
	return Contact;
});
if (typeof define !== 'function') {
	var define = require('amdefine')(module);
}

define('src/collision_detector',["goom-math", "./contact", "./intersection_tests", "./primitives","./rigid_body"], function(Mathematics, Contact, IntersectionTests, Primitives) {
	/**
		Creates a new CollisionDetector.
		@class Collision detectors are used to check collisions between primitive and fetch the contact data.
		@param {Number} cache_limit The max size of the cache for contacts, cache_limit contacts will be created
			when the constructor is called, and they will be reused throught time. When the contact number is over
			the limit, new contacts will be instantiated but not cached.
		@property {Number} MAX_CONTACTS The max size of the cache for contacts.
		@property {Array} contactCache An array holding the cached contacts.

		@exports CollisionDetector as Physics.CollisionDetector
	*/
	var CollisionDetector = (function() {
		function CollisionDetector(cache_limit) {
			this.MAX_CONTACTS = cache_limit === null || cache_limit === undefined ? 30: cache_limit;
			this.contactCache = new Array(this.MAX_CONTACTS);
			this.contactCacheTop = 0;
			//Initialize the contact cache.
			for (var i = this.MAX_CONTACTS; i >= 0; i--) {
				this.contactCache[i] = new Contact();
			}
			//Helper data used to avoid instantiating objects at runtime.
			this.__helperVector = new Mathematics.Vector3D();
			this.__helperVector2 = new Mathematics.Vector3D();
			this.__helperVector3 = new Mathematics.Vector3D();
			this.__helperVector4 = new Mathematics.Vector3D();
			this.__helperVector5 = new Mathematics.Vector3D();
			this.__helperVector6 = new Mathematics.Vector3D();
			this.__helperVector7 = new Mathematics.Vector3D();

			this.__helperMatrix = new Mathematics.Matrix3D();
			this.__axisTestData = new Array(3);
		}

		//We will need to go through each combination of vectors, and it's best not to create this on the fly.
		CollisionDetector.multipliers = [[1, 1, 1], [-1, 1, 1], [1, -1, 1], [-1, -1, 1], [1, 1, -1], [-1, 1, -1], [1, -1, -1], [-1, -1, -1]];

		/**
			Returns the last free contact in the cache if there is any, and creates a new contact when there isn't.
			@inner
		*/
		CollisionDetector.prototype.__getFreeContact = function() {
			//When there is no contacts free, instantiate a new one.
			if (this.contactCacheTop >= this.MAX_CONTACTS) return new Contact();
			//Return the last empty contact from cache.
			this.contactCacheTop++;
			return this.contactCache[this.contactCacheTop - 1];
		};

		/**
			Sets the contact cache to the initial status, reusing the cached contacts.
		*/
		CollisionDetector.prototype.clearCache = function() {
			this.contactCacheTop = 0;
		};

		/**
			Checks for contacts between two spheres.
			@param {Physics.Sphere} sphere_one The first sphere to check.
			@param {Physics.Sphere} sphere_two The second sphere to check.
			@param data Data affecting the contact resolution.
			@param {Array} contacts The array where contact data will be stored.
			@returns {Boolean} true if contacts where found, false otherwise.
		*/
		CollisionDetector.prototype.sphereAndSphere = function(sphere_one, sphere_two, data, contacts) {
			//Cache sphere positions
			var position_one = sphere_one.position(this.__helperVector);
			var position_two = sphere_two.position(this.__helperVector2);
			//Find the vector between the objects
			var midline = position_one.substract(position_two, this.__helperVector2);
			var size = midline.magnitude();
			//Check if we are too far away
			if ((size <= 0) || (size >= (sphere_one.radious + sphere_two.radious))) return false;
			
			//Prepare the contact.
			var contact = this.__getFreeContact();
			//Manually create the normal
			midline.scale(1 / size, contact.normal);
			position_one.substract(midline.scale(0.5), contact.point);
			contact.penetration = sphere_one.radious + sphere_two.radious - size;
			contact.setContactData(sphere_one.body, sphere_two.body, data.restitution, data.friction);
			contacts.push(contact);
			return true;
		};

		/**
			Checks for contacts between a sphere and a half-plane(a plane with infinite solid behind de plane).
			@param {Physics.Sphere} sphere The sphere to check.
			@param {Physics.Plane} plane The plane to check.
			@param data Data affecting the contact resolution.
			@param {Array} contacts The array where contact data will be stored.
			@returns {Boolean} true if contacts where found, false otherwise.
		*/
		CollisionDetector.prototype.sphereAndHalfSpace = function(sphere, plane, data, contacts) {
			var sphere_position = sphere.position(this.__helperVector);
			var distance = plane.normal.dotProduct(sphere_position) - sphere.radious - plane.offset;
			//Check if we are too far away
			if (distance >= 0) return false;
			//Prepare the contact.
			var contact = this.__getFreeContact();
			sphere_position.substract(plane.normal.scale(distance + sphere.radious, contact.point), contact.point);
			plane.normal.clone(contact.normal);
			contact.penetration = -distance;
			contact.setContactData(sphere.body, null, data.restitution, data.friction);
			contacts.push(contact);
			return true;
		};

		/**
			Checks for contacts between a box and a half space.
			@param {Physics.Box} box The box to check.
			@param {Physics.Plane} plane The plane to check.
			@param data Data affecting the contact resolution.
			@param {Array} contacts The array where contact data will be stored.
			@returns {Boolean} true if contacts where found, false otherwise.
		*/
		CollisionDetector.prototype.boxAndHalfSpace = function(box, plane, data, contacts) {
			//Early-out check for intersection, performance improvement
			if (!IntersectionTests.boxAndHalfSpace(box, plane)) return false;
			
			contacts_found = false;
			//Go through the different vertices
			for (i = 0; i <= 7; i++) {
				var vertex_position = this.__helperVector.set(CollisionDetector.multipliers[i][0], CollisionDetector.multipliers[i][1], CollisionDetector.multipliers[i][2]);
				vertex_position.componentProduct(box.halfSize);
				box.transformationMatrix.transformVector(vertex_position);
				//Calculate the distance from the plane
				var vertex_distance = vertex_position.dotProduct(plane.normal);
				if (vertex_distance <= plane.offset) {
					//Create contact data
					var contact = this.__getFreeContact();
					//The point is halfway between the vertex and the point.
					plane.normal.scale(-(vertex_distance - plane.offset), contact.point);
					contact.point.add(vertex_position);
					plane.normal.clone(contact.normal);
					contact.penetration = plane.offset - vertex_distance;
					contact.setContactData(box.body, null, data.restitution, data.friction);
					contacts.push(contact);
					contacts_found = true;
				}
			}
			return contacts_found;
		};

		/**
			Checks for contacts between a box and a sphere.
			@param {Physics.Box} box The box to check.
			@param {Physics.Sphere} sphere The sphere to check.
			@param data Data affecting the contact resolution.
			@param {Array} contacts The array where contact data will be stored.
			@returns {Boolean} true if contacts where found, false otherwise.
		*/
		CollisionDetector.prototype.boxAndSphere = function(box, sphere, data, contacts) {
			//We need the center of the sphere to be in box coordinates
			var sphere_center = sphere.position(this.__helperVector);
			var relative_center = box.transformationMatrix.transformInverseVector(sphere_center, this.__helperMatrix);

			//Early-out check
			if (((Math.abs(relative_center.x) - sphere.radious) > box.halfSize.x) ||
				((Math.abs(relative_center.y) - sphere.radious) > box.halfSize.y) ||
				((Math.abs(relative_center.z) - sphere.radious) > box.halfSize.z)) {

				return false;
			}

			//Clamp each coordinate to the box
			var distance = relative_center.x;
			if (distance > box.halfSize.x) distance = box.halfSize.x;
			if (distance < -box.halfSize.x) distance = -box.halfSize.x;
			this.__helperVector2.x = distance;

			distance = relative_center.y;
			if (distance > box.halfSize.y) distance = box.halfSize.y;
			if (distance < -box.halfSize.y) distance = -box.halfSize.y;
			this.__helperVector2.y = distance;
			
			distance = relative_center.z;
			if (distance > box.halfSize.z) distance = box.halfSize.z;
			if (distance < -box.halfSize.z) distance = -box.halfSize.z;
			this.__helperVector2.z = distance;
			
			distance = this.__helperVector2.substract(relative_center, this.__helperVector).squaredMagnitude();
			if (distance > (sphere.radious * sphere.radious)) return false;
			
			sphere_center = sphere.position(this.__helperVector);
			//Create contact data
			var contact = this.__getFreeContact();
			box.transformationMatrix.transformVector(this.__helperVector2);
			this.__helperVector2.clone(contact.point);
			this.__helperVector2.substract(sphere_center).normalize().clone(contact.normal);
			contact.penetration = sphere.radious - Math.sqrt(distance);
			contact.setContactData(box.body, sphere.body, data.restitution, data.friction);
			contacts.push(contact);
			return true;
		};

		/**
			If the given boxes collide and the penetration on the requested axis is smaller than the previously smallest,
			it updates these values.
			@inner
		*/
		CollisionDetector.prototype.__testAxis = function(box_one, box_two, axis, to_centre, index, smallest_penetration, smallest_case) {
			//Don't check almost parallel axes
			if (axis.squaredMagnitude() < 0.0001) {
				this.__axisTestData[0] = true, this.__axisTestData[1] = smallest_penetration, this.__axisTestData[2] = smallest_case;
				return this.__axisTestData;
			}

			//Get the penetration
			axis.normalize();
			var projection_one = box_one.halfSize.x * Math.abs(axis.dotProduct(box_one.axisVector(0, this.__helperVector))) +
								box_one.halfSize.y * Math.abs(axis.dotProduct(box_one.axisVector(1, this.__helperVector))) +
								box_one.halfSize.z * Math.abs(axis.dotProduct(box_one.axisVector(2, this.__helperVector)));
			var projection_two = box_two.halfSize.x * Math.abs(axis.dotProduct(box_two.axisVector(0, this.__helperVector))) +
								box_two.halfSize.y * Math.abs(axis.dotProduct(box_two.axisVector(1, this.__helperVector))) +
								box_two.halfSize.z * Math.abs(axis.dotProduct(box_two.axisVector(2, this.__helperVector)));
			var penetration = projection_one + projection_two - Math.abs(to_centre.dotProduct(axis));
		
			if (penetration < 0) {
				this.__axisTestData[0] = false, this.__axisTestData[1] = smallest_penetration, this.__axisTestData[2] = smallest_case;
				return this.__axisTestData;
			}

			//Did we find a contact with smaller penetration?
			if (penetration < smallest_penetration) {
				smallest_penetration = penetration;
				smallest_case = index;
			}
			
			this.__axisTestData[0] = true, this.__axisTestData[1] = smallest_penetration, this.__axisTestData[2] = smallest_case;
			return this.__axisTestData;
		};

		var x = 'x', y = 'y', z = 'z';
		var axis_index_to_name = function() {
			switch(index) {
				case 0: return x;
				case 1: return y;
				case 2: return z;
			}
		};

		/**
			Checks for contacts between two boxes.
			@param {Physics.Box} box_one The first box to check.
			@param {Physics.Box} box_two The second box to check.
			@param data Data affecting the contact resolution.
			@param {Array} contacts The array where contact data will be stored.
			@returns {Boolean} true if contacts where found, false otherwise.
		*/
		CollisionDetector.prototype.boxAndBox = function(box_one, box_two, data, contacts) {
			//Get the vector from the position of the first box to the position of the second box
			var to_centre = box_two.position(this.__helperVector2).substract(box_one.position(this.__helperVector));
			//Assume there is no contact
			var penetration, best, axis_test_data;
			penetration = best = Number.MAX_VALUE;
			var test = false;

			//Test the different axes for intersections keeping track of the smallest penetration
			axis_test_data = this.__testAxis(box_one, box_two, box_one.axisVector(0, this.__helperVector3), to_centre, 0, penetration, best), test = axis_test_data[0], penetration = axis_test_data[1], best = axis_test_data[2];
			if (!test) return false;
			axis_test_data = this.__testAxis(box_one, box_two, box_one.axisVector(1, this.__helperVector3), to_centre, 1, penetration, best), test = axis_test_data[0], penetration = axis_test_data[1], best = axis_test_data[2];
			if (!test) return false;
			axis_test_data = this.__testAxis(box_one, box_two, box_one.axisVector(2, this.__helperVector3), to_centre, 2, penetration, best), test = axis_test_data[0], penetration = axis_test_data[1], best = axis_test_data[2];
			if (!test) return false;
			axis_test_data = this.__testAxis(box_one, box_two, box_two.axisVector(0, this.__helperVector3), to_centre, 3, penetration, best), test = axis_test_data[0], penetration = axis_test_data[1], best = axis_test_data[2];
			if (!test) return false;
			axis_test_data = this.__testAxis(box_one, box_two, box_two.axisVector(1, this.__helperVector3), to_centre, 4, penetration, best), test = axis_test_data[0], penetration = axis_test_data[1], best = axis_test_data[2];
			if (!test) return false;
			axis_test_data = this.__testAxis(box_one, box_two, box_two.axisVector(2, this.__helperVector3), to_centre, 5, penetration, best), test = axis_test_data[0], penetration = axis_test_data[1], best = axis_test_data[2];
			if (!test) return false;
			//Store the best axis-major
			var best_single_axis = best;
			axis_test_data = this.__testAxis(box_one, box_two, box_two.axisVector(0, this.__helperVector3).crossProduct(box_one.axisVector(0, this.__helperVector)), to_centre, 6, penetration, best), test = axis_test_data[0], penetration = axis_test_data[1], best = axis_test_data[2];
			if (!test) return false;
			axis_test_data = this.__testAxis(box_one, box_two, box_two.axisVector(1, this.__helperVector3).crossProduct(box_one.axisVector(0, this.__helperVector)), to_centre, 7, penetration, best), test = axis_test_data[0], penetration = axis_test_data[1], best = axis_test_data[2];
			if (!test) return false;
			axis_test_data = this.__testAxis(box_one, box_two, box_two.axisVector(2, this.__helperVector3).crossProduct(box_one.axisVector(0, this.__helperVector)), to_centre, 8, penetration, best), test = axis_test_data[0], penetration = axis_test_data[1], best = axis_test_data[2];
			if (!test) return false;
			axis_test_data = this.__testAxis(box_one, box_two, box_two.axisVector(0, this.__helperVector3).crossProduct(box_one.axisVector(1, this.__helperVector)), to_centre, 9, penetration, best), test = axis_test_data[0], penetration = axis_test_data[1], best = axis_test_data[2];
			if (!test) return false;
			axis_test_data = this.__testAxis(box_one, box_two, box_two.axisVector(1, this.__helperVector3).crossProduct(box_one.axisVector(1, this.__helperVector)), to_centre, 10, penetration, best), test = axis_test_data[0], penetration = axis_test_data[1], best = axis_test_data[2];
			if (!test) return false;
			axis_test_data = this.__testAxis(box_one, box_two, box_two.axisVector(2, this.__helperVector3).crossProduct(box_one.axisVector(1, this.__helperVector)), to_centre, 11, penetration, best), test = axis_test_data[0], penetration = axis_test_data[1], best = axis_test_data[2];
			if (!test) return false;
			axis_test_data = this.__testAxis(box_one, box_two, box_two.axisVector(0, this.__helperVector3).crossProduct(box_one.axisVector(2, this.__helperVector)), to_centre, 12, penetration, best), test = axis_test_data[0], penetration = axis_test_data[1], best = axis_test_data[2];
			if (!test) return false;
			axis_test_data = this.__testAxis(box_one, box_two, box_two.axisVector(1, this.__helperVector3).crossProduct(box_one.axisVector(2, this.__helperVector)), to_centre, 13, penetration, best), test = axis_test_data[0], penetration = axis_test_data[1], best = axis_test_data[2];
			if (!test) return false;
			axis_test_data = this.__testAxis(box_one, box_two, box_two.axisVector(2, this.__helperVector3).crossProduct(box_one.axisVector(2, this.__helperVector)), to_centre, 14, penetration, best), test = axis_test_data[0], penetration = axis_test_data[1], best = axis_test_data[2];
			if (!test) return false;

			var contact;
			if (best < 3) {
				//We've got a vertex of box two on a face of box_one
				//Create contact data
				contact = this.__getFreeContact();
				box_one.axisVector(best, contact.normal);
				if (contact.normal.dotProduct(to_centre) > 0) {
					contact.normal.scale(-1);
				}

				box_two.halfSize.clone(contact.point);
				if (box_two.axisVector(0, this.__helperVector3).dotProduct(contact.normal) < 0) contact.point.x = -contact.point.x;
				if (box_two.axisVector(1, this.__helperVector3).dotProduct(contact.normal) < 0) contact.point.y = -contact.point.y;
				if (box_two.axisVector(2, this.__helperVector3).dotProduct(contact.normal) < 0) contact.point.z = -contact.point.z;
				
				box_two.transformationMatrix.transformVector(contact.point);
				contact.penetration = penetration;
				contact.setContactData(box_one.body, box_two.body, data.restitution, data.friction);
				contacts.push(contact);
				return true;
			} else if (best < 6) {
				//We've got a vertex of box one on a face of two
				best -= 3;
				to_centre.scale(-1);
				//Create contact data
				contact = this.__getFreeContact();
				box_two.axisVector(best, contact.normal);
				if (contact.normal.dotProduct(to_centre) > 0) {
					contact.normal.scale(-1);
				}

				box_one.halfSize.clone(contact.point);
				if (box_one.axisVector(0, this.__helperVector3).dotProduct(contact.normal) < 0) contact.point.x = -contact.point.x;
				if (box_one.axisVector(1, this.__helperVector3).dotProduct(contact.normal) < 0) contact.point.y = -contact.point.y;
				if (box_one.axisVector(2, this.__helperVector3).dotProduct(contact.normal) < 0) contact.point.z = -contact.point.z;
				
				box_one.transformationMatrix.transformVector(contact.point);
				contact.penetration = penetration;
				contact.setContactData(box_two.body, box_one.body, data.restitution, data.friction);
				contacts.push(contact);
				return true;
			} else {
				//Edge-to-edge contact
				best -= 6;
				var box_two_axis_index = best % 3;
				var box_one_axis_index = (best - box_two_axis_index) / 3;
				var box_one_axis = box_one.axisVector(box_one_axis_index, this.__helperVector);
				var box_two_axis = box_two.axisVector(box_two_axis_index, this.__helperVector3);
				var axis = box_two_axis.crossProduct(box_one_axis, this.__helperVector4).normalize();
				//This axis should point from box one to box two
				if (axis.dotProduct(to_centre) > 0) axis.scale(-1);
				//Get the edges
				var point_on_box_one_edge = box_one.halfSize.clone(this.__helperVector5);
				var point_on_box_two_edge = box_two.halfSize.clone(this.__helperVector6);
		
				if (0 === box_one_axis_index) {
					point_on_box_one_edge.x = 0;
				} else if (box_one.axisVector(0, this.__helperVector7).dotProduct(axis) > 0) {
					point_on_box_one_edge.x = -point_on_box_one_edge.x;
				}
				if (0 === box_two_axis_index) {
					point_on_box_two_edge.x = 0;
				} else if (box_two.axisVector(0, this.__helperVector7).dotProduct(axis) < 0) {
					point_on_box_two_edge.x = -point_on_box_two_edge.x;
				}

				if (1 === box_one_axis_index) {
					point_on_box_one_edge.y = 0;
				} else if (box_one.axisVector(1, this.__helperVector7).dotProduct(axis) > 0) {
					point_on_box_one_edge.y = -point_on_box_one_edge.y;
				}
				if (1 === box_two_axis_index) {
					point_on_box_two_edge.y = 0;
				} else if (box_two.axisVector(1, this.__helperVector7).dotProduct(axis) < 0) {
					point_on_box_two_edge.y = -point_on_box_two_edge.y;
				}

				if (2 === box_one_axis_index) {
					point_on_box_one_edge.z = 0;
				} else if (box_one.axisVector(2, this.__helperVector7).dotProduct(axis) > 0) {
					point_on_box_one_edge.z = -point_on_box_one_edge.z;
				}
				if (2 === box_two_axis_index) {
					point_on_box_two_edge.z = 0;
				} else if (box_two.axisVector(2, this.__helperVector7).dotProduct(axis) < 0) {
					point_on_box_two_edge.z = -point_on_box_two_edge.z;
				}
		
				//Move the edges into world coordinates
				box_one.transformationMatrix.transformVector(point_on_box_one_edge);
				box_two.transformationMatrix.transformVector(point_on_box_two_edge);
				//Find out the point of closest approach of the two segments
				var use_one = best_single_axis > 2;
				var sm_one = box_one_axis.squaredMagnitude();
				var sm_two = box_two_axis.squaredMagnitude();
				var dp_one_two = box_two_axis.dotProduct(box_one_axis);
				var to_st = point_on_box_one_edge.substract(point_on_box_two_edge, this.__helperVector7);
				var dp_st_one = box_one_axis.dotProduct(to_st);
				var dp_st_two = box_two_axis.dotProduct(to_st);
				var denominator = sm_one * sm_two - dp_one_two * dp_one_two;
				var vertex;
				//Zero denominator indicates parallel lines
				if (Math.abs(denominator) < 0.0001) {
					vertex = use_one ? point_on_box_one_edge : point_on_box_two_edge;
				} else {
					var mua = (dp_one_two * dp_st_two - sm_two * dp_st_one) / denominator;
					var mub = (sm_one * dp_st_two - dp_one_two * dp_st_one) / denominator;

					//If either of the edges has the nearest point out of bounds, then the edges aren't crossed, we have an edge-face contact.
					var box_one_axis_name = axis_index_to_name(box_one_axis_index);
					var box_two_axis_name = axis_index_to_name(box_two_axis_index);

					if (mua > box_one.halfSize[box_one_axis_name] || mua < -box_one.halfSize[box_one_axis_name] || mub > box_two.halfSize[box_two_axis_name] || mub < -box_two.halfSize[box_two_axis_name]) {
						vertex = use_one ? point_on_box_one_edge : point_on_box_two_edge;
					} else {
						point_on_box_one_edge.add(box_one_axis.scale(mua));
						point_on_box_two_edge.add(box_two_axis.scale(mub));
						vertex = point_on_box_one_edge.scale(0.5).add(point_on_box_two_edge.scale(0.5));
					}
				}

				//Create contact data
				contact = this.__getFreeContact();
				vertex.clone(contact.point);
				axis.clone(contact.normal);
				contact.penetration = penetration;
				contact.setContactData(box_one.body, box_two.body, data.restitution, data.friction);
				contacts.push(contact);
				return true;
			}
			
			return false;
		};

		/**
			Checks for contacts between the two given bodies. This will check for contacts between all the primitives
			in the given bodies.
			@param {Physics.RigidBody} first_body The first body to check.
			@param {Physics.RigidBody} second_body The second body to check.
			@param data Data affecting the contact resolution.
			@param {Array} contacts The array where contact data will be stored.
			@returns {Boolean} true if contacts where found, false otherwise.
		*/
		CollisionDetector.prototype.checkForContacts = function(first_body, second_body, data, contacts) {
			var primitive_one, primitive_two, i, j, len, len2, ref2;
			var result = false;
			var ref = first_body.primitives;

			for (i = 0, len = ref.length; i < len; i++) {
				primitive_one = ref[i];
				ref2 = second_body.primitives;
				for (j = 0, len2 = ref2.length; j < len2; j++) {
					//Check each primitive in the first body with the primitives in the second body
					primitive_two = ref2[j];
					if (primitive_one instanceof Primitives.Plane) {
						if (primitive_two instanceof Primitives.Box) {
							result = result || this.boxAndHalfSpace(primitive_two, primitive_one, data, contacts);
						} else if (primitive_two instanceof Primitives.Sphere) {
							result = result || this.sphereAndHalfSpace(primitive_two, primitive_one, data, contacts);
						}
						continue;
					}
						
					if (primitive_one instanceof Primitives.Box) {
						if (primitive_two instanceof Primitives.Plane) {
							result = result || this.boxAndHalfSpace(primitive_one, primitive_two, data, contacts);
						} else if (primitive_two instanceof Primitives.Sphere) {
							result = result || this.boxAndSphere(primitive_one, primitive_two, data, contacts);
						} else if (primitive_two instanceof Primitives.Box) {
							result = result || this.boxAndBox(primitive_one, primitive_two, data, contacts);
						}
						continue;
					}

					if (primitive_one instanceof Primitives.Sphere) {
						if (primitive_two instanceof Primitives.Plane) {
							result = result || this.sphereAndHalfSpace(primitive_one, primitive_two, data, contacts);
						} else if (primitive_two instanceof Primitives.Box) {
							result = result || this.boxAndSphere(primitive_two, primitive_one, data, contacts);
						} else if (primitive_two instanceof Primitives.Sphere) {
							result = result || this.sphereAndSphere(primitive_one, primitive_two, data, contacts);
						}
						continue;
					}
				}
			}
			return result;
		};

		/**
			Checks for contacts between a body and a plane. This will check for contacts between all the primitives
			in the given body.
			@param {Physics.RigidBody} body The body to check.
			@param {Physics.Primitives.Plane} plane The plane to check.
			@param data Data affecting the contact resolution.
			@param {Array} contacts The array where contact data will be stored.
			@returns {Boolean} true if contacts where found, false otherwise.
		*/
		CollisionDetector.prototype.checkForContactsWithPlane = function(body, plane, data, contacts) {
			var primitive_one, result, i, len, ref;
			result = false;
			ref = body.primitives;

			for (i = 0, len = ref.length; i < len; i++) {
				primitive_one = ref[i];
				if (primitive_one instanceof Primitives.Box) {
					result = result || this.boxAndHalfSpace(primitive_one, plane, data, contacts);
					continue;
				}
				if (primitive_one instanceof Primitives.Sphere) {
					result = result || this.sphereAndHalfSpace(primitive_one, primitive_two, data, contacts);
					continue;
				}
			}
			return result;
		};
		return CollisionDetector;
	})();
	return CollisionDetector;
});
if (typeof define !== 'function') {
	var define = require('amdefine')(module);
}

define('src/force_generator',["./rigid_body"], function(RigidBody) {
	/**
		Creates a force generator.
		@class Used to add forces to one or more bodies. This class is just a interface, should
		be expanded and implemented by actual generators.
		@exports ForceGenerador as Physics.ForceGenerator
	*/
	var ForceGenerator = (function() {
		function ForceGenerator() {}

		/**
			Calculates and updates the force applied to the given rigid body.
			@param {Physics.RigidBody} body The rigid body where the given force will be applied.
			@param {Number} duration  Duration of the applied force.
		*/
		ForceGenerator.prototype.updateForce = function(body, duration) {};
		return ForceGenerator;
	})();
	return ForceGenerator;
});
if (typeof define !== 'function') {
	var define = require('amdefine')(module);
}

define('src/body_force_registry',["goom-math", "./force_generator", "./rigid_body"], function(Mathematics) {
	/**
		Creates a BodyForceRegistry.
		@class This class is used to register the force generators that affect ay given particles
		in the physics engine.
		@exports BodyForceRegistry as Physics.BodyForceRegistry.
		@property {Array} registrations An array holding the body and force generator pairs,
		will hold the pair as an object with a body key to the rigid body and a
		forceGenerator key to the ForceGenerator.
	*/
	var BodyForceRegistry = (function() {
		function BodyForceRegistry() {
			this.registrations = [];
		}

		/**
			Adds a new RigidBody and ForceGenerator pair to the registry.
			@param {Physics.RigidBody} body The rigid body.
			@param {Physics.ForceGenerator} force_generator The force generator affecting the given
			rigid body.
		*/
		BodyForceRegistry.prototype.add = function(body, force_generator) {
			this.registrations.push({"body": body, "forceGenerator": force_generator});
		};

		/**
			Removes a RigidBody and ForceGenerator pair from the registry.
			@param {Physics.RigidBody} body The rigid body.
			@param {Physics.ForceGenerator} force_generator The force generator affecting the given
			rigid body.
		*/
		BodyForceRegistry.prototype.remove = function(body, force_generator) {
			var i, r, len;
			for (i = 0, len = this.registrations.length; i < len; i++) {
				r = this.registrations[i];
				if (r.body === body && r.forceGenerator === force_generator) {
					this.registrations.splice(i, 1);
					return;
				}
			}
		};

		/**
			Clears all the registrations in the registry.
		*/
		BodyForceRegistry.prototype.clear = function() {
			var i, r, len;
			for (i = 0, len = this.registrations.length; i < len; i++) {
				this.registrations.pop();
			}
		};

		/**
			Calls all the force generators to update the corresponding body's forces.
			@param {Number} Duration of the applied force.
		*/
		BodyForceRegistry.prototype.updateForces = function(duration) {
			var r, i, len, ref;
			ref = this.registrations;
			
			for (i = 0, len = ref.length; i < len; i++) {
				r = ref[i];
				r.forceGenerator.updateForce(r.body, duration);
			}
		};

		return BodyForceRegistry;
	})();

	return BodyForceRegistry;
});
if (typeof define !== 'function') {
	var define = require('amdefine')(module);
}

define('src/gravity',["goom-math", "./force_generator"], function(Mathematics, ForceGenerator) {
	var __hasProp = Object.prototype.hasOwnProperty, __extends = function(child, parent) {
		for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; }
		function ctor() { this.constructor = child; }
		ctor.prototype = parent.prototype;
		child.prototype = new ctor();
		child.__super__ = parent.prototype;
		return child;
	};

	/**
		Creates a gravity force generator.
		@class Used to apply gravity to the bodies in the world.
		@exports Gravity as Physics.Gravity
		@param {Math.Vector3D} gravity The acceleration due to gravity.
		@property {Math.Vector3D} gravity The acceleration due to gravity.
	*/
	var Gravity = (function() {
		__extends(Gravity, ForceGenerator);

		function Gravity(gravity) {
			this.gravity = gravity;
		}

		/**
			This is an internal varible used to avoid the creation of new objects at runtime.
			@inner
		*/
		__vector = new Mathematics.Vector3D();

		/**
			Calculates and updates the force applied to the given rigid body.
			@param {Physics.RigidBody} body The rigid body where the given force will be applied.
			@param {Number} duration  Duration of the applied force.
		*/
		Gravity.prototype.updateForce = function(body, duration) {
			if (!body.hasFiniteMass()) return;
			body.applyForce(this.gravity.scale(body.getMass(), __vector));
		};

		return Gravity;
	})();

	return Gravity;
});
if (typeof define !== 'function') {
	var define = require('amdefine')(module);
}

define('src/goom-physics',["./body_force_registry", "./bounding_sphere", "./bounding_volume_hierarchy_node", "./collision_detector", "./contact",
		"./force_generator", "./gravity", "./intersection_tests", "./primitives", "./rigid_body"],
		function(BodyForceRegistry, BoundingSphere, BoundingVolumeHierarchyNode, CollisionDetector, Contact,
			ForceGenerator, Gravity, IntersectionTests, Primitives, RigidBody) {
	Physics = {};
	Physics.BodyForceRegistry = BodyForceRegistry;
	Physics.BoundingSphere = BoundingSphere;
	Physics.BoundingVolumeHierarchyNode = BoundingVolumeHierarchyNode;
	Physics.CollisionDetector = CollisionDetector;
	Physics.Contact = Contact;
	Physics.ForceGenerator = ForceGenerator;
	Physics.Gravity = Gravity;
	Physics.IntersectionTests = IntersectionTests;
	Physics.Primitives = Primitives;
	Physics.RigidBody = RigidBody;
	return Physics;
});